<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>GlobalStudio v7.0 - Video Editor</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    /* ===== CARDGIFT STYLE THEME ===== */
    :root {
      --cg-gold: #FFD700;
      --cg-gold-dark: #B8860B;
      --cg-bg-dark: #0f1419;
      --cg-bg-card: #1a1f2e;
      --cg-bg-lighter: #242b3d;
      --cg-text: #E8E8E8;
      --cg-text-muted: #9CA3AF;
      --cg-accent: #00d4ff;
      --cg-green: #4CAF50;
      --cg-red: #f44336;
      --cg-purple: #9c27b0;
      --cg-border: rgba(255, 215, 0, 0.2);
    }
    
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; 
      background: linear-gradient(135deg, var(--cg-bg-dark) 0%, #1a1a2e 50%, var(--cg-bg-dark) 100%);
      color: var(--cg-text); 
      overflow: hidden;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    
    input[type="range"] { -webkit-appearance: none; background: rgba(255,215,0,0.2); border-radius: 4px; height: 6px; width: 100%; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: var(--cg-gold); border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px rgba(255,215,0,0.5); }
    
    select { background: var(--cg-bg-lighter); border: 1px solid var(--cg-border); color: var(--cg-text); padding: 6px 10px; border-radius: 6px; font-size: 12px; }
    select:focus { outline: none; border-color: var(--cg-gold); }
    
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: var(--cg-bg-dark); }
    ::-webkit-scrollbar-thumb { background: var(--cg-gold-dark); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--cg-gold); }
    
    .btn { padding: 8px 14px; border-radius: 8px; cursor: pointer; font-size: 12px; border: none; transition: all 0.2s; touch-action: manipulation; font-weight: 500; }
    .btn:active { transform: scale(0.95); }
    .btn-primary { background: linear-gradient(135deg, var(--cg-gold), var(--cg-gold-dark)); color: #000; box-shadow: 0 2px 10px rgba(255,215,0,0.3); }
    .btn-primary:hover:not(:disabled) { box-shadow: 0 4px 20px rgba(255,215,0,0.5); }
    .btn-secondary { background: var(--cg-bg-lighter); border: 1px solid var(--cg-border); color: var(--cg-text); }
    .btn-secondary:hover:not(:disabled) { border-color: var(--cg-gold); color: var(--cg-gold); }
    .btn-danger { background: rgba(244,67,54,0.2); border: 1px solid rgba(244,67,54,0.4); color: var(--cg-red); }
    .btn-success { background: rgba(76,175,80,0.2); border: 1px solid rgba(76,175,80,0.4); color: var(--cg-green); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .btn:hover:not(:disabled) { transform: scale(1.02); filter: brightness(1.1); }
    
    .timeline-segment { position: absolute; height: 100%; border-radius: 6px; display: flex; align-items: center; padding-left: 8px; font-size: 10px; color: #fff; cursor: grab; overflow: hidden; user-select: none; border: 1px solid rgba(255,255,255,0.1); }
    .timeline-segment:hover { box-shadow: 0 0 15px rgba(255,215,0,0.4); border-color: var(--cg-gold); }
    .timeline-segment.selected { border: 2px solid var(--cg-gold); box-shadow: 0 0 20px rgba(255,215,0,0.6); }
    
    .resize-handle { position: absolute; top: 0; bottom: 0; width: 10px; cursor: ew-resize; background: rgba(255,215,0,0.1); }
    .resize-handle:hover { background: rgba(255,215,0,0.5); }
    .resize-handle.left { left: 0; border-radius: 6px 0 0 6px; }
    .resize-handle.right { right: 0; border-radius: 0 6px 6px 0; }
    
    .track-row { display: flex; align-items: center; margin-bottom: 6px; height: 44px; }
    .track-label { width: 70px; font-size: 11px; flex-shrink: 0; padding-right: 10px; font-weight: 500; }
    .track-content { flex: 1; height: 100%; background: var(--cg-bg-lighter); border-radius: 8px; position: relative; border: 1px solid rgba(255,255,255,0.05); cursor: pointer; }
    .track-content:hover { border-color: rgba(255,215,0,0.2); }
    
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); backdrop-filter: blur(10px); display: flex; align-items: center; justify-content: center; z-index: 1000; }
    .modal-content { background: linear-gradient(145deg, var(--cg-bg-card), var(--cg-bg-dark)); border-radius: 16px; padding: 24px; width: 500px; max-width: 95%; max-height: 90vh; overflow: auto; border: 1px solid var(--cg-border); box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
    .progress-bar { height: 12px; background: var(--cg-bg-lighter); border-radius: 6px; overflow: hidden; margin: 12px 0; border: 1px solid var(--cg-border); }
    .progress-fill { height: 100%; background: linear-gradient(90deg, var(--cg-gold), var(--cg-gold-dark)); transition: width 0.3s; }
    
    .transition-badge { position: absolute; right: -12px; top: 50%; transform: translateY(-50%); width: 26px; height: 26px; background: var(--cg-gold); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 11px; z-index: 10; cursor: pointer; border: 2px solid var(--cg-bg-dark); box-shadow: 0 2px 8px rgba(255,215,0,0.4); }
    .transition-badge:hover { transform: translateY(-50%) scale(1.2); }
    
    .input-small { width: 65px; padding: 6px; background: var(--cg-bg-lighter); border: 1px solid var(--cg-border); border-radius: 6px; color: var(--cg-text); font-size: 11px; text-align: center; }
    .input-small:focus { outline: none; border-color: var(--cg-gold); }
    
    .lang-btn { padding: 5px 10px; border: none; background: transparent; color: var(--cg-text-muted); cursor: pointer; border-radius: 6px; font-size: 11px; font-weight: 500; }
    .lang-btn.active { background: rgba(255,215,0,0.2); color: var(--cg-gold); }
    
    .input-field { width: 100%; padding: 10px 12px; background: var(--cg-bg-lighter); border: 1px solid var(--cg-border); border-radius: 8px; color: var(--cg-text); font-size: 13px; }
    .input-field:focus { outline: none; border-color: var(--cg-gold); }
    
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
    .shimmer { background: linear-gradient(90deg, transparent, rgba(255,215,0,0.3), transparent); background-size: 200% 100%; animation: shimmer 2s infinite; }
    
    /* Timeline toolbar */
    .timeline-toolbar { display: flex; align-items: center; gap: 10px; padding: 8px 15px; background: var(--cg-bg-card); border-bottom: 1px solid var(--cg-border); flex-wrap: wrap; }
    .zoom-control { display: flex; align-items: center; gap: 6px; padding: 4px 8px; background: var(--cg-bg-lighter); border-radius: 8px; border: 1px solid var(--cg-border); }
    .zoom-btn { width: 28px; height: 28px; border-radius: 6px; border: none; background: var(--cg-bg-dark); color: var(--cg-gold); cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; }
    .zoom-btn:hover { background: var(--cg-gold); color: #000; }
    .play-btn { width: 44px; height: 36px; border-radius: 8px; border: none; background: linear-gradient(135deg, var(--cg-gold), var(--cg-gold-dark)); color: #000; cursor: pointer; font-size: 16px; box-shadow: 0 2px 10px rgba(255,215,0,0.3); }
    .play-btn:hover { box-shadow: 0 4px 20px rgba(255,215,0,0.5); }
    .nav-btn { width: 36px; height: 36px; border-radius: 8px; border: 1px solid var(--cg-border); background: var(--cg-bg-lighter); color: var(--cg-text); cursor: pointer; }
    .nav-btn:hover { border-color: var(--cg-gold); color: var(--cg-gold); }
    
    @media (max-width: 768px) {
      .desktop-only { display: none !important; }
      .track-label { width: 50px; font-size: 10px; }
      .timeline-segment { font-size: 9px; min-width: 35px; }
      .btn { padding: 10px 12px; }
      .timeline-toolbar { padding: 6px 10px; gap: 6px; }
    }
    @media (min-width: 769px) {
      .mobile-only { display: none !important; }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    // ==================== TRANSLATIONS ====================
    const T = {
      en: {
        media: 'Media', audio: 'Audio', text: 'Text', banner: 'Banner',
        addMedia: 'Add Video/Photo', addVoice: 'Add Voice', addMusic: 'Add Music', addText: 'Add Text',
        export: 'Export', format: 'Format', duplicate: 'Duplicate', delete: 'Delete', cancel: 'Cancel', start: 'Start', save: 'Save', copyHtml: 'Copy HTML',
        position: 'Position', duration: 'Duration', volume: 'Volume', transition: 'Transition', transDur: 'Trans. duration',
        color: 'Color', size: 'Size', animation: 'Animation', startTime: 'Start', endTime: 'End', selectElement: 'Select element',
        quality: 'Quality', medium: 'Medium', high: 'High', ultra: 'Ultra', exportTime: 'Export time',
        addMediaHint: 'Add media files', emptySection: 'Empty section', recording: 'Recording...', preparing: 'Preparing...', prepAudio: 'Preparing audio...', saving: 'Saving...', error: 'Error',
        bannerTitle: 'Banner Generator', yourText: 'Your text', background: 'Background', effect: 'Effect', noEffect: 'No effect', pulse: 'Pulse', shimmer: 'Shimmer', gradient: 'Gradient', logo: 'Logo', uploadLogo: 'Upload', link: 'Link', preview: 'Preview', savedBanners: 'Saved',
        trans: { none: 'None', fade: 'Fade', slideLeft: 'Slide Left', slideRight: 'Slide Right', slideUp: 'Slide Up', slideDown: 'Slide Down', zoomIn: 'Zoom In', zoomOut: 'Zoom Out', wipeLeft: 'Wipe Left', wipeRight: 'Wipe Right' },
        anim: { none: 'None', fadeIn: 'Fade In', fadeOut: 'Fade Out', fadeInOut: 'Fade In/Out' },
        fmt: { youtube: 'YouTube HD', youtube4k: 'YouTube 4K', tiktok: 'TikTok/Reels', square: 'Square', cinema: 'Cinema 21:9' }
      },
      ru: {
        media: '–ú–µ–¥–∏–∞', audio: '–ó–≤—É–∫', text: '–¢–µ–∫—Å—Ç', banner: '–ë–∞–Ω–Ω–µ—Ä',
        addMedia: '–î–æ–±–∞–≤–∏—Ç—å –≤–∏–¥–µ–æ/—Ñ–æ—Ç–æ', addVoice: '–î–æ–±–∞–≤–∏—Ç—å –≥–æ–ª–æ—Å', addMusic: '–î–æ–±–∞–≤–∏—Ç—å –º—É–∑—ã–∫—É', addText: '–î–æ–±–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç',
        export: '–≠–∫—Å–ø–æ—Ä—Ç', format: '–§–æ—Ä–º–∞—Ç', duplicate: '–î—É–±–ª—å', delete: '–£–¥–∞–ª–∏—Ç—å', cancel: '–û—Ç–º–µ–Ω–∞', start: '–ù–∞—á–∞—Ç—å', save: '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å', copyHtml: '–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å HTML',
        position: '–ü–æ–∑–∏—Ü–∏—è', duration: '–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å', volume: '–ì—Ä–æ–º–∫–æ—Å—Ç—å', transition: '–ü–µ—Ä–µ—Ö–æ–¥', transDur: '–î–ª–∏—Ç. –ø–µ—Ä–µ—Ö–æ–¥–∞',
        color: '–¶–≤–µ—Ç', size: '–†–∞–∑–º–µ—Ä', animation: '–ê–Ω–∏–º–∞—Ü–∏—è', startTime: '–ù–∞—á–∞–ª–æ', endTime: '–ö–æ–Ω–µ—Ü', selectElement: '–í—ã–±–µ—Ä–∏—Ç–µ —ç–ª–µ–º–µ–Ω—Ç',
        quality: '–ö–∞—á–µ—Å—Ç–≤–æ', medium: '–°—Ä–µ–¥–Ω–µ–µ', high: '–í—ã—Å–æ–∫–æ–µ', ultra: '–£–ª—å—Ç—Ä–∞', exportTime: '–í—Ä–µ–º—è –∑–∞–ø–∏—Å–∏',
        addMediaHint: '–î–æ–±–∞–≤—å—Ç–µ –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã', emptySection: '–ü—É—Å—Ç–æ–π —É—á–∞—Å—Ç–æ–∫', recording: '–ó–∞–ø–∏—Å—å...', preparing: '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...', prepAudio: '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∞—É–¥–∏–æ...', saving: '–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...', error: '–û—à–∏–±–∫–∞',
        bannerTitle: '–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –±–∞–Ω–Ω–µ—Ä–æ–≤', yourText: '–í–∞—à —Ç–µ–∫—Å—Ç', background: '–§–æ–Ω', effect: '–≠—Ñ—Ñ–µ–∫—Ç', noEffect: '–ë–µ–∑ —ç—Ñ—Ñ–µ–∫—Ç–∞', pulse: '–ü—É–ª—å—Å–∞—Ü–∏—è', shimmer: '–ú–µ—Ä—Ü–∞–Ω–∏–µ', gradient: '–ì—Ä–∞–¥–∏–µ–Ω—Ç', logo: '–õ–æ–≥–æ—Ç–∏–ø', uploadLogo: '–ó–∞–≥—Ä—É–∑–∏—Ç—å', link: '–°—Å—ã–ª–∫–∞', preview: '–ü—Ä–µ–≤—å—é', savedBanners: '–°–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ',
        trans: { none: '–ë–µ–∑ –ø–µ—Ä–µ—Ö–æ–¥–∞', fade: '–ü–ª–∞–≤–Ω–æ–µ', slideLeft: '–°–ª–∞–π–¥ –≤–ª–µ–≤–æ', slideRight: '–°–ª–∞–π–¥ –≤–ø—Ä–∞–≤–æ', slideUp: '–°–ª–∞–π–¥ –≤–≤–µ—Ä—Ö', slideDown: '–°–ª–∞–π–¥ –≤–Ω–∏–∑', zoomIn: '–£–≤–µ–ª–∏—á–µ–Ω–∏–µ', zoomOut: '–£–º–µ–Ω—å—à–µ–Ω–∏–µ', wipeLeft: '–®—Ç–æ—Ä–∫–∞ –≤–ª–µ–≤–æ', wipeRight: '–®—Ç–æ—Ä–∫–∞ –≤–ø—Ä–∞–≤–æ' },
        anim: { none: '–ë–µ–∑ –∞–Ω–∏–º–∞—Ü–∏–∏', fadeIn: '–ü–æ—è–≤–ª–µ–Ω–∏–µ', fadeOut: '–ò—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ', fadeInOut: '–ü–æ—è–≤–ª–µ–Ω–∏–µ+–∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ' },
        fmt: { youtube: 'YouTube HD', youtube4k: 'YouTube 4K', tiktok: 'TikTok/Reels', square: '–ö–≤–∞–¥—Ä–∞—Ç', cinema: '–ö–∏–Ω–æ 21:9' }
      },
      uk: {
        media: '–ú–µ–¥—ñ–∞', audio: '–ó–≤—É–∫', text: '–¢–µ–∫—Å—Ç', banner: '–ë–∞–Ω–µ—Ä',
        addMedia: '–î–æ–¥–∞—Ç–∏ –≤—ñ–¥–µ–æ/—Ñ–æ—Ç–æ', addVoice: '–î–æ–¥–∞—Ç–∏ –≥–æ–ª–æ—Å', addMusic: '–î–æ–¥–∞—Ç–∏ –º—É–∑–∏–∫—É', addText: '–î–æ–¥–∞—Ç–∏ —Ç–µ–∫—Å—Ç',
        export: '–ï–∫—Å–ø–æ—Ä—Ç', format: '–§–æ—Ä–º–∞—Ç', duplicate: '–î—É–±–ª—å', delete: '–í–∏–¥–∞–ª–∏—Ç–∏', cancel: '–°–∫–∞—Å—É–≤–∞—Ç–∏', start: '–ü–æ—á–∞—Ç–∏', save: '–ó–±–µ—Ä–µ–≥—Ç–∏', copyHtml: '–ö–æ–ø—ñ—é–≤–∞—Ç–∏ HTML',
        position: '–ü–æ–∑–∏—Ü—ñ—è', duration: '–¢—Ä–∏–≤–∞–ª—ñ—Å—Ç—å', volume: '–ì—É—á–Ω—ñ—Å—Ç—å', transition: '–ü–µ—Ä–µ—Ö—ñ–¥', transDur: '–¢—Ä–∏–≤. –ø–µ—Ä–µ—Ö–æ–¥—É',
        color: '–ö–æ–ª—ñ—Ä', size: '–†–æ–∑–º—ñ—Ä', animation: '–ê–Ω—ñ–º–∞—Ü—ñ—è', startTime: '–ü–æ—á–∞—Ç–æ–∫', endTime: '–ö—ñ–Ω–µ—Ü—å', selectElement: '–í–∏–±–µ—Ä—ñ—Ç—å –µ–ª–µ–º–µ–Ω—Ç',
        quality: '–Ø–∫—ñ—Å—Ç—å', medium: '–°–µ—Ä–µ–¥–Ω—è', high: '–í–∏—Å–æ–∫–∞', ultra: '–£–ª—å—Ç—Ä–∞', exportTime: '–ß–∞—Å –∑–∞–ø–∏—Å—É',
        addMediaHint: '–î–æ–¥–∞–π—Ç–µ –º–µ–¥—ñ–∞—Ñ–∞–π–ª–∏', emptySection: '–ü–æ—Ä–æ–∂–Ω—è –¥—ñ–ª—è–Ω–∫–∞', recording: '–ó–∞–ø–∏—Å...', preparing: '–ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞...', prepAudio: '–ü—ñ–¥–≥–æ—Ç–æ–≤–∫–∞ –∞—É–¥—ñ–æ...', saving: '–ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è...', error: '–ü–æ–º–∏–ª–∫–∞',
        bannerTitle: '–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –±–∞–Ω–µ—Ä—ñ–≤', yourText: '–í–∞—à —Ç–µ–∫—Å—Ç', background: '–§–æ–Ω', effect: '–ï—Ñ–µ–∫—Ç', noEffect: '–ë–µ–∑ –µ—Ñ–µ–∫—Ç—É', pulse: '–ü—É–ª—å—Å–∞—Ü—ñ—è', shimmer: '–ú–µ—Ä–µ—Ö—Ç—ñ–Ω–Ω—è', gradient: '–ì—Ä–∞–¥—ñ—î–Ω—Ç', logo: '–õ–æ–≥–æ—Ç–∏–ø', uploadLogo: '–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏', link: '–ü–æ—Å–∏–ª–∞–Ω–Ω—è', preview: '–ü–µ—Ä–µ–≥–ª—è–¥', savedBanners: '–ó–±–µ—Ä–µ–∂–µ–Ω—ñ',
        trans: { none: '–ë–µ–∑ –ø–µ—Ä–µ—Ö–æ–¥—É', fade: '–ü–ª–∞–≤–Ω–∏–π', slideLeft: '–°–ª–∞–π–¥ –≤–ª—ñ–≤–æ', slideRight: '–°–ª–∞–π–¥ –≤–ø—Ä–∞–≤–æ', slideUp: '–°–ª–∞–π–¥ –≤–≥–æ—Ä—É', slideDown: '–°–ª–∞–π–¥ –≤–Ω–∏–∑', zoomIn: '–ó–±—ñ–ª—å—à–µ–Ω–Ω—è', zoomOut: '–ó–º–µ–Ω—à–µ–Ω–Ω—è', wipeLeft: '–®—Ç–æ—Ä–∫–∞ –≤–ª—ñ–≤–æ', wipeRight: '–®—Ç–æ—Ä–∫–∞ –≤–ø—Ä–∞–≤–æ' },
        anim: { none: '–ë–µ–∑ –∞–Ω—ñ–º–∞—Ü—ñ—ó', fadeIn: '–ü–æ—è–≤–∞', fadeOut: '–ó–Ω–∏–∫–Ω–µ–Ω–Ω—è', fadeInOut: '–ü–æ—è–≤–∞+–∑–Ω–∏–∫–Ω–µ–Ω–Ω—è' },
        fmt: { youtube: 'YouTube HD', youtube4k: 'YouTube 4K', tiktok: 'TikTok/Reels', square: '–ö–≤–∞–¥—Ä–∞—Ç', cinema: '–ö—ñ–Ω–æ 21:9' }
      }
    };

    // –¢–∏–ø—ã –ø–µ—Ä–µ—Ö–æ–¥–æ–≤
    const TRANSITIONS = {
      none: '‚¨ú', fade: 'üå´Ô∏è', slideLeft: '‚¨ÖÔ∏è', slideRight: '‚û°Ô∏è',
      slideUp: '‚¨ÜÔ∏è', slideDown: '‚¨áÔ∏è', zoomIn: 'üîç', zoomOut: 'üîé',
      wipeLeft: '‚óÄÔ∏è', wipeRight: '‚ñ∂Ô∏è'
    };

    const GlobalStudio = () => {
      // –Ø–∑—ã–∫
      const [lang, setLang] = useState(() => {
        const saved = localStorage.getItem('gs_lang');
        if (saved && T[saved]) return saved;
        const browser = navigator.language.split('-')[0];
        return T[browser] ? browser : 'en';
      });
      const t = T[lang];
      
      useEffect(() => { localStorage.setItem('gs_lang', lang); }, [lang]);
      
      // –ú–æ–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è
      const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
      useEffect(() => {
        const handler = () => setIsMobile(window.innerWidth <= 768);
        window.addEventListener('resize', handler);
        return () => window.removeEventListener('resize', handler);
      }, []);
      
      // –ë–∞–Ω–Ω–µ—Ä—ã
      const [banners, setBanners] = useState([]);

      const [clips, setClips] = useState([]);
      const [voiceSegments, setVoiceSegments] = useState([]);
      const [musicSegments, setMusicSegments] = useState([]);
      const [textOverlays, setTextOverlays] = useState([]);
      const [selectedItem, setSelectedItem] = useState(null);
      const [currentTime, setCurrentTime] = useState(0);
      const [isPlaying, setIsPlaying] = useState(false);
      const [projectSettings, setProjectSettings] = useState({ width: 1920, height: 1080, format: 'youtube' });
      const [activeTab, setActiveTab] = useState('media');
      const [isExporting, setIsExporting] = useState(false);
      const [exportProgress, setExportProgress] = useState(0);
      const [exportStatus, setExportStatus] = useState('');
      const [exportPhase, setExportPhase] = useState('');
      const [showExportModal, setShowExportModal] = useState(false);
      const [exportQuality, setExportQuality] = useState('high');
      const [showTemplates, setShowTemplates] = useState(false);
      const [showTransitionModal, setShowTransitionModal] = useState(null);
      const [dragging, setDragging] = useState(null);
      
      // NEW v7.0: Timeline zoom
      const [timelineZoom, setTimelineZoom] = useState(1);
      const [showHelp, setShowHelp] = useState(false);

      const videoRef = useRef(null);
      const voiceRefs = useRef({});
      const musicRefs = useRef({});
      const fileInputRef = useRef(null);
      const voiceInputRef = useRef(null);
      const musicInputRef = useRef(null);
      const playIntervalRef = useRef(null);
      const timelineRef = useRef(null);
      const videoCache = useRef({});
      const exportCancelRef = useRef(false);

      const templates = [
        { id: 'youtube', name: 'YouTube HD', width: 1920, height: 1080, icon: 'üì∫' },
        { id: 'youtube4k', name: 'YouTube 4K', width: 3840, height: 2160, icon: 'üì∫' },
        { id: 'tiktok', name: 'TikTok/Reels', width: 1080, height: 1920, icon: 'üì±' },
        { id: 'square', name: '–ö–≤–∞–¥—Ä–∞—Ç', width: 1080, height: 1080, icon: '‚¨ú' },
        { id: 'cinema', name: '–ö–∏–Ω–æ 21:9', width: 2560, height: 1080, icon: 'üé¨' },
      ];

      const qualityPresets = {
        medium: { bitrate: 5000000, label: '–°—Ä–µ–¥–Ω–∏–π', desc: '5 Mbps' },
        high: { bitrate: 10000000, label: '–í—ã—Å–æ–∫–∏–π', desc: '10 Mbps' },
        ultra: { bitrate: 20000000, label: '–£–ª—å—Ç—Ä–∞', desc: '20 Mbps' }
      };

      const getRealEndTime = useCallback(() => {
        let maxEnd = 0;
        clips.forEach(c => { const end = c.startTime + (c.trimEnd - c.trimStart); if (end > maxEnd) maxEnd = end; });
        voiceSegments.forEach(s => { const end = s.startTime + (s.trimEnd - s.trimStart); if (end > maxEnd) maxEnd = end; });
        musicSegments.forEach(s => { const end = s.startTime + (s.trimEnd - s.trimStart); if (end > maxEnd) maxEnd = end; });
        textOverlays.forEach(t => { if (t.endTime > maxEnd) maxEnd = t.endTime; });
        return maxEnd;
      }, [clips, voiceSegments, musicSegments, textOverlays]);

      const realEndTime = getRealEndTime();
      const totalDuration = Math.max(realEndTime + 30, 60);

      // ==================== FILE UPLOAD ====================

      const handleFileUpload = async (e) => {
        const files = Array.from(e.target.files);
        let currentEnd = getRealEndTime();
        
        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          const url = URL.createObjectURL(file);
          const fileId = Date.now() + i;
          
          if (file.type.startsWith('video/')) {
            const video = document.createElement('video');
            video.src = url;
            video.preload = 'auto';
            video.muted = true;
            
            await new Promise(resolve => {
              video.onloadedmetadata = () => {
                videoCache.current[fileId] = { element: video, file, url };
                setClips(prev => [...prev, {
                  id: fileId, type: 'video', src: url, name: file.name,
                  duration: video.duration, trimStart: 0, trimEnd: video.duration,
                  startTime: currentEnd, audioDetached: false, volume: 1,
                  transition: 'none', transitionDuration: 0.5
                }]);
                currentEnd += video.duration;
                resolve();
              };
            });
          } else if (file.type.startsWith('image/')) {
            const img = new Image();
            img.src = url;
            await new Promise(resolve => {
              img.onload = () => {
                videoCache.current[fileId] = { element: img, file, url };
                resolve();
              };
            });
            setClips(prev => [...prev, {
              id: fileId, type: 'image', src: url, name: file.name,
              duration: 5, trimStart: 0, trimEnd: 5, startTime: currentEnd,
              transition: 'none', transitionDuration: 0.5
            }]);
            currentEnd += 5;
          }
        }
        e.target.value = '';
      };

      const handleVoiceUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        const fileId = Date.now();
        const audio = document.createElement('audio');
        audio.src = url;
        audio.onloadedmetadata = () => {
          videoCache.current[fileId] = { file, url };
          setVoiceSegments(prev => [...prev, {
            id: fileId, src: url, name: file.name,
            duration: audio.duration, trimStart: 0, trimEnd: audio.duration,
            startTime: 0, volume: 1
          }]);
        };
        e.target.value = '';
      };

      const handleMusicUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        const fileId = Date.now();
        const audio = document.createElement('audio');
        audio.src = url;
        audio.onloadedmetadata = () => {
          videoCache.current[fileId] = { file, url };
          setMusicSegments(prev => [...prev, {
            id: fileId, src: url, name: file.name,
            duration: audio.duration, trimStart: 0, trimEnd: audio.duration,
            startTime: 0, volume: 0.3
          }]);
        };
        e.target.value = '';
      };

      // ==================== CRUD ====================

      const updateClip = (id, updates) => setClips(prev => prev.map(c => c.id === id ? { ...c, ...updates } : c));
      const updateVoice = (id, updates) => setVoiceSegments(prev => prev.map(s => s.id === id ? { ...s, ...updates } : s));
      const updateMusic = (id, updates) => setMusicSegments(prev => prev.map(s => s.id === id ? { ...s, ...updates } : s));
      const updateText = (id, updates) => setTextOverlays(prev => prev.map(t => t.id === id ? { ...t, ...updates } : t));
      const deleteClip = (id) => { setClips(prev => prev.filter(c => c.id !== id)); if (selectedItem?.id === id) setSelectedItem(null); };
      const deleteVoice = (id) => { setVoiceSegments(prev => prev.filter(s => s.id !== id)); if (selectedItem?.id === id) setSelectedItem(null); };
      const deleteMusic = (id) => { setMusicSegments(prev => prev.filter(s => s.id !== id)); if (selectedItem?.id === id) setSelectedItem(null); };
      const deleteText = (id) => { setTextOverlays(prev => prev.filter(t => t.id !== id)); if (selectedItem?.id === id) setSelectedItem(null); };

      // –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
      const duplicateSelectedItem = () => {
        if (!selectedItem) return;
        const { type, id } = selectedItem;
        let segment;
        if (type === 'clip') segment = clips.find(c => c.id === id);
        else if (type === 'voice') segment = voiceSegments.find(s => s.id === id);
        else if (type === 'music') segment = musicSegments.find(s => s.id === id);
        else if (type === 'text') segment = textOverlays.find(t => t.id === id);
        if (!segment) return;
        
        const newId = Date.now();
        let newSegment;
        
        if (type === 'text') {
          const duration = segment.endTime - segment.startTime;
          newSegment = { ...segment, id: newId, startTime: segment.endTime, endTime: segment.endTime + duration };
        } else {
          const segDuration = segment.trimEnd - segment.trimStart;
          newSegment = { ...segment, id: newId, startTime: segment.startTime + segDuration };
        }
        
        if (videoCache.current[id]) videoCache.current[newId] = videoCache.current[id];
        
        if (type === 'clip') setClips(prev => [...prev, newSegment]);
        else if (type === 'voice') setVoiceSegments(prev => [...prev, newSegment]);
        else if (type === 'music') setMusicSegments(prev => [...prev, newSegment]);
        else if (type === 'text') setTextOverlays(prev => [...prev, newSegment]);
        
        setSelectedItem({ type, id: newId });
      };

      // –†–∞–∑—Ä–µ–∑–∞—Ç—å –∫–ª–∏–ø –≤ —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏
      const splitSelectedItem = () => {
        if (!selectedItem || selectedItem.type === 'text') return;
        const { type, id } = selectedItem;
        let segment;
        if (type === 'clip') segment = clips.find(c => c.id === id);
        else if (type === 'voice') segment = voiceSegments.find(s => s.id === id);
        else if (type === 'music') segment = musicSegments.find(s => s.id === id);
        if (!segment) return;
        
        const segStart = segment.startTime;
        const segEnd = segStart + (segment.trimEnd - segment.trimStart);
        if (currentTime <= segStart || currentTime >= segEnd) return;
        
        const relTime = currentTime - segStart;
        const splitPoint = segment.trimStart + relTime;
        
        const first = { ...segment, id: Date.now(), trimEnd: splitPoint };
        const second = { ...segment, id: Date.now() + 1, trimStart: splitPoint, startTime: currentTime };
        
        if (type === 'clip') setClips(prev => [...prev.filter(c => c.id !== id), first, second]);
        else if (type === 'voice') setVoiceSegments(prev => [...prev.filter(s => s.id !== id), first, second]);
        else if (type === 'music') setMusicSegments(prev => [...prev.filter(s => s.id !== id), first, second]);
        
        setSelectedItem({ type, id: second.id });
      };

      // –û—Ç—Å–æ–µ–¥–∏–Ω–∏—Ç—å/–ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å –∞—É–¥–∏–æ –æ—Ç –≤–∏–¥–µ–æ
      const toggleAudioDetach = (clipId) => {
        const clip = clips.find(c => c.id === clipId);
        if (clip && clip.type === 'video') {
          updateClip(clipId, { audioDetached: !clip.audioDetached });
        }
      };

      // ==================== NEW v7.0: ZOOM & SPLIT ====================
      const zoomIn = () => setTimelineZoom(prev => Math.min(prev * 1.5, 8));
      const zoomOut = () => setTimelineZoom(prev => Math.max(prev / 1.5, 0.25));
      const zoomReset = () => setTimelineZoom(1);

      const splitAtPlayhead = () => {
        if (!selectedItem) return;
        const { type, id } = selectedItem;
        
        if (type === 'clip') {
          const clip = clips.find(c => c.id === id);
          if (!clip) return;
          const clipEnd = clip.startTime + (clip.trimEnd - clip.trimStart);
          if (currentTime <= clip.startTime || currentTime >= clipEnd) return;
          
          const splitPoint = clip.trimStart + (currentTime - clip.startTime);
          const part1 = { ...clip, trimEnd: splitPoint };
          const part2 = { ...clip, id: Date.now(), trimStart: splitPoint, startTime: currentTime };
          setClips(prev => prev.map(c => c.id === id ? part1 : c).concat(part2));
          setSelectedItem({ type: 'clip', id: part2.id });
        } else if (type === 'voice') {
          const seg = voiceSegments.find(s => s.id === id);
          if (!seg) return;
          const segEnd = seg.startTime + (seg.trimEnd - seg.trimStart);
          if (currentTime <= seg.startTime || currentTime >= segEnd) return;
          const splitPoint = seg.trimStart + (currentTime - seg.startTime);
          setVoiceSegments(prev => prev.map(s => s.id === id ? { ...s, trimEnd: splitPoint } : s).concat({ ...seg, id: Date.now(), trimStart: splitPoint, startTime: currentTime }));
        } else if (type === 'music') {
          const seg = musicSegments.find(s => s.id === id);
          if (!seg) return;
          const segEnd = seg.startTime + (seg.trimEnd - seg.trimStart);
          if (currentTime <= seg.startTime || currentTime >= segEnd) return;
          const splitPoint = seg.trimStart + (currentTime - seg.startTime);
          setMusicSegments(prev => prev.map(s => s.id === id ? { ...s, trimEnd: splitPoint } : s).concat({ ...seg, id: Date.now(), trimStart: splitPoint, startTime: currentTime }));
        }
      };

      const setPlayheadTime = (timeStr) => {
        const parts = timeStr.split(':');
        let seconds = 0;
        if (parts.length === 2) seconds = parseInt(parts[0]) * 60 + parseFloat(parts[1]);
        else seconds = parseFloat(parts[0]);
        if (!isNaN(seconds) && seconds >= 0) setCurrentTime(Math.min(seconds, getRealEndTime() || totalDuration));
      };

      const addTextOverlay = () => {
        const newText = {
          id: Date.now(),
          text: '–ù–æ–≤—ã–π —Ç–µ–∫—Å—Ç',
          x: 50, y: 50,
          fontSize: 48,
          color: '#ffffff',
          startTime: currentTime,
          endTime: currentTime + 5,
          animation: 'none' // none, fadeIn, fadeOut, fadeInOut, typewriter
        };
        setTextOverlays(prev => [...prev, newText]);
        setSelectedItem({ type: 'text', id: newText.id });
      };

      // ==================== DRAG ====================

      const handleDragStart = (e, type, id, mode = 'move') => {
        e.stopPropagation();
        const rect = timelineRef.current.getBoundingClientRect();
        const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left - 60;
        let segment;
        if (type === 'clip') segment = clips.find(c => c.id === id);
        else if (type === 'voice') segment = voiceSegments.find(s => s.id === id);
        else if (type === 'music') segment = musicSegments.find(s => s.id === id);
        else if (type === 'text') segment = textOverlays.find(t => t.id === id);
        if (!segment) return;
        
        const startTime = segment.startTime;
        const startTrimStart = segment.trimStart || 0;
        const startTrimEnd = segment.trimEnd || segment.endTime || 5;
        
        setDragging({ type, id, mode, startX: x, startTime, startTrimStart, startTrimEnd, startEndTime: segment.endTime });
        setSelectedItem({ type, id });
      };

      const handleDragMove = useCallback((e) => {
        if (!dragging || !timelineRef.current) return;
        const rect = timelineRef.current.getBoundingClientRect();
        const trackWidth = rect.width - 60;
        const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left - 60;
        const deltaTime = ((x - dragging.startX) / trackWidth) * totalDuration;
        const { type, id, mode } = dragging;
        
        if (type === 'text') {
          const text = textOverlays.find(t => t.id === id);
          if (!text) return;
          if (mode === 'move') {
            const duration = text.endTime - text.startTime;
            const newStart = Math.max(0, dragging.startTime + deltaTime);
            updateText(id, { startTime: newStart, endTime: newStart + duration });
          } else if (mode === 'resize-left') {
            const newStart = Math.max(0, Math.min(dragging.startTime + deltaTime, dragging.startEndTime - 0.5));
            updateText(id, { startTime: newStart });
          } else if (mode === 'resize-right') {
            const newEnd = Math.max(dragging.startTime + 0.5, dragging.startEndTime + deltaTime);
            updateText(id, { endTime: newEnd });
          }
          return;
        }
        
        if (mode === 'move') {
          const newStartTime = Math.max(0, dragging.startTime + deltaTime);
          if (type === 'clip') updateClip(id, { startTime: newStartTime });
          else if (type === 'voice') updateVoice(id, { startTime: newStartTime });
          else if (type === 'music') updateMusic(id, { startTime: newStartTime });
        } else if (mode === 'resize-left') {
          let segment;
          if (type === 'clip') segment = clips.find(c => c.id === id);
          else if (type === 'voice') segment = voiceSegments.find(s => s.id === id);
          else if (type === 'music') segment = musicSegments.find(s => s.id === id);
          if (!segment) return;
          const newTrimStart = Math.max(0, Math.min(dragging.startTrimStart + deltaTime, dragging.startTrimEnd - 0.5));
          const newStartTime = dragging.startTime + (newTrimStart - dragging.startTrimStart);
          if (type === 'clip') updateClip(id, { trimStart: newTrimStart, startTime: Math.max(0, newStartTime) });
          else if (type === 'voice') updateVoice(id, { trimStart: newTrimStart, startTime: Math.max(0, newStartTime) });
          else if (type === 'music') updateMusic(id, { trimStart: newTrimStart, startTime: Math.max(0, newStartTime) });
        } else if (mode === 'resize-right') {
          let segment;
          if (type === 'clip') segment = clips.find(c => c.id === id);
          else if (type === 'voice') segment = voiceSegments.find(s => s.id === id);
          else if (type === 'music') segment = musicSegments.find(s => s.id === id);
          if (!segment) return;
          const maxTrimEnd = segment.type === 'image' ? 300 : segment.duration;
          const newTrimEnd = Math.max(dragging.startTrimStart + 0.5, Math.min(maxTrimEnd, dragging.startTrimEnd + deltaTime));
          if (type === 'clip') updateClip(id, { trimEnd: newTrimEnd, ...(segment.type === 'image' ? { duration: newTrimEnd } : {}) });
          else if (type === 'voice') updateVoice(id, { trimEnd: newTrimEnd });
          else if (type === 'music') updateMusic(id, { trimEnd: newTrimEnd });
        }
      }, [dragging, totalDuration, clips, voiceSegments, musicSegments, textOverlays]);

      const handleDragEnd = useCallback(() => setDragging(null), []);

      useEffect(() => {
        if (dragging) {
          window.addEventListener('mousemove', handleDragMove);
          window.addEventListener('mouseup', handleDragEnd);
          window.addEventListener('touchmove', handleDragMove);
          window.addEventListener('touchend', handleDragEnd);
          return () => {
            window.removeEventListener('mousemove', handleDragMove);
            window.removeEventListener('mouseup', handleDragEnd);
            window.removeEventListener('touchmove', handleDragMove);
            window.removeEventListener('touchend', handleDragEnd);
          };
        }
      }, [dragging, handleDragMove, handleDragEnd]);

      // ==================== KEYBOARD SHORTCUTS ====================
      useEffect(() => {
        const handleKeyDown = (e) => {
          // Ctrl+D - –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
          if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
            e.preventDefault();
            duplicateSelectedItem();
          }
          // Space - –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ/–ø–∞—É–∑–∞
          if (e.key === ' ' && e.target.tagName !== 'INPUT') {
            e.preventDefault();
            togglePlay();
          }
          // Delete/Backspace - —É–¥–∞–ª–µ–Ω–∏–µ
          if ((e.key === 'Delete' || e.key === 'Backspace') && e.target.tagName !== 'INPUT') {
            if (!selectedItem) return;
            e.preventDefault();
            const { type, id } = selectedItem;
            if (type === 'clip') deleteClip(id);
            else if (type === 'voice') deleteVoice(id);
            else if (type === 'music') deleteMusic(id);
            else if (type === 'text') deleteText(id);
          }
          // NEW v7.0: S - split
          if (e.key === 's' && e.target.tagName !== 'INPUT' && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            splitAtPlayhead();
          }
          // NEW v7.0: +/- zoom
          if ((e.key === '+' || e.key === '=') && e.target.tagName !== 'INPUT') {
            e.preventDefault();
            zoomIn();
          }
          if (e.key === '-' && e.target.tagName !== 'INPUT') {
            e.preventDefault();
            zoomOut();
          }
          if (e.key === '0' && e.target.tagName !== 'INPUT' && !e.ctrlKey) {
            e.preventDefault();
            zoomReset();
          }
          // NEW v7.0: Home/End navigation
          if (e.key === 'Home') {
            e.preventDefault();
            setCurrentTime(0);
          }
          if (e.key === 'End') {
            e.preventDefault();
            setCurrentTime(getRealEndTime());
          }
          // NEW v7.0: Arrow keys ¬±1 sec
          if (e.key === 'ArrowLeft' && e.target.tagName !== 'INPUT') {
            e.preventDefault();
            setCurrentTime(prev => Math.max(0, prev - 1));
          }
          if (e.key === 'ArrowRight' && e.target.tagName !== 'INPUT') {
            e.preventDefault();
            setCurrentTime(prev => Math.min(getRealEndTime() || totalDuration, prev + 1));
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [selectedItem, clips, voiceSegments, musicSegments, textOverlays, currentTime]);

      // ==================== PLAYBACK ====================

      const togglePlay = () => {
        const endTime = getRealEndTime();
        if (endTime <= 0) return;
        
        if (isPlaying) {
          setIsPlaying(false);
          clearInterval(playIntervalRef.current);
          videoRef.current?.pause();
          Object.values(voiceRefs.current).forEach(a => a?.pause());
          Object.values(musicRefs.current).forEach(a => a?.pause());
        } else {
          if (currentTime >= endTime) setCurrentTime(0);
          setIsPlaying(true);
          const startMs = Date.now();
          const startPlayTime = currentTime >= endTime ? 0 : currentTime;
          
          playIntervalRef.current = setInterval(() => {
            const elapsed = (Date.now() - startMs) / 1000;
            const newTime = startPlayTime + elapsed;
            
            if (newTime >= endTime) {
              setIsPlaying(false);
              clearInterval(playIntervalRef.current);
              setCurrentTime(endTime);
              videoRef.current?.pause();
              Object.values(voiceRefs.current).forEach(a => a?.pause());
              Object.values(musicRefs.current).forEach(a => a?.pause());
              return;
            }
            
            [...voiceSegments, ...musicSegments].forEach(seg => {
              const isVoice = voiceSegments.includes(seg);
              const refs = isVoice ? voiceRefs : musicRefs;
              const audio = refs.current[seg.id];
              if (!audio) return;
              const segEnd = seg.startTime + (seg.trimEnd - seg.trimStart);
              if (newTime >= seg.startTime && newTime < segEnd) {
                if (audio.paused) {
                  audio.currentTime = seg.trimStart + (newTime - seg.startTime);
                  audio.volume = seg.volume;
                  audio.play().catch(() => {});
                }
              } else if (!audio.paused) {
                audio.pause();
              }
            });
            
            setCurrentTime(newTime);
          }, 50);
        }
      };

      const getCurrentClip = () => {
        for (const clip of clips) {
          const start = clip.startTime;
          const end = start + (clip.trimEnd - clip.trimStart);
          if (currentTime >= start && currentTime < end) {
            return { clip, localTime: clip.trimStart + (currentTime - start) };
          }
        }
        return null;
      };

      // –ü–æ–ª—É—á–∏—Ç—å –≤–∏–¥–∏–º—ã–µ —Ç–µ–∫—Å—Ç—ã
      const getVisibleTexts = () => {
        return textOverlays.filter(t => currentTime >= t.startTime && currentTime < t.endTime);
      };

      // –†–∞—Å—Å—á–∏—Ç–∞—Ç—å opacity –∏ —ç—Ñ—Ñ–µ–∫—Ç—ã –¥–ª—è —Ç–µ–∫—Å—Ç–∞
      const getTextStyle = (t) => {
        const duration = t.endTime - t.startTime;
        const elapsed = currentTime - t.startTime;
        const remaining = t.endTime - currentTime;
        const fadeTime = 0.5;
        
        let opacity = 1;
        if (t.animation === 'fadeIn' || t.animation === 'fadeInOut') {
          if (elapsed < fadeTime) opacity = elapsed / fadeTime;
        }
        if (t.animation === 'fadeOut' || t.animation === 'fadeInOut') {
          if (remaining < fadeTime) opacity = Math.min(opacity, remaining / fadeTime);
        }
        
        return { opacity: Math.max(0, Math.min(1, opacity)) };
      };

      const currentClipData = getCurrentClip();
      const visibleTexts = getVisibleTexts();

      useEffect(() => {
        if (currentClipData?.clip?.type === 'video' && videoRef.current) {
          const video = videoRef.current;
          if (video.src !== currentClipData.clip.src) video.src = currentClipData.clip.src;
          if (Math.abs(video.currentTime - currentClipData.localTime) > 0.3) video.currentTime = currentClipData.localTime;
          video.muted = currentClipData.clip.audioDetached || false;
          video.volume = currentClipData.clip.volume || 1;
          if (isPlaying && video.paused) video.play().catch(() => {});
          else if (!isPlaying && !video.paused) video.pause();
        }
      }, [currentClipData, isPlaying]);

      useEffect(() => () => clearInterval(playIntervalRef.current), []);

      const formatTime = (s) => {
        const m = Math.floor(s / 60).toString().padStart(2, '0');
        const sec = Math.floor(s % 60).toString().padStart(2, '0');
        return m + ':' + sec;
      };
      
      const formatTimeMs = (s) => {
        const m = Math.floor(s / 60).toString().padStart(2, '0');
        const sec = Math.floor(s % 60).toString().padStart(2, '0');
        const ms = Math.floor((s % 1) * 10);
        return m + ':' + sec + '.' + ms;
      };

      // ==================== TRANSITIONS ====================

      const applyTransition = (ctx, canvas, prevFrame, currentFrame, progress, transitionType) => {
        const w = canvas.width;
        const h = canvas.height;
        
        switch (transitionType) {
          case 'fade':
            if (prevFrame) {
              ctx.globalAlpha = 1 - progress;
              ctx.drawImage(prevFrame, 0, 0, w, h);
            }
            ctx.globalAlpha = progress;
            ctx.drawImage(currentFrame, 0, 0, w, h);
            ctx.globalAlpha = 1;
            break;
            
          case 'slideLeft':
            if (prevFrame) ctx.drawImage(prevFrame, -w * progress, 0, w, h);
            ctx.drawImage(currentFrame, w * (1 - progress), 0, w, h);
            break;
            
          case 'slideRight':
            if (prevFrame) ctx.drawImage(prevFrame, w * progress, 0, w, h);
            ctx.drawImage(currentFrame, -w * (1 - progress), 0, w, h);
            break;
            
          case 'slideUp':
            if (prevFrame) ctx.drawImage(prevFrame, 0, -h * progress, w, h);
            ctx.drawImage(currentFrame, 0, h * (1 - progress), w, h);
            break;
            
          case 'slideDown':
            if (prevFrame) ctx.drawImage(prevFrame, 0, h * progress, w, h);
            ctx.drawImage(currentFrame, 0, -h * (1 - progress), w, h);
            break;
            
          case 'zoomIn':
            if (prevFrame) {
              ctx.globalAlpha = 1 - progress;
              ctx.drawImage(prevFrame, 0, 0, w, h);
            }
            ctx.globalAlpha = progress;
            const scale = 0.5 + progress * 0.5;
            const offsetX = (w - w * scale) / 2;
            const offsetY = (h - h * scale) / 2;
            ctx.drawImage(currentFrame, offsetX, offsetY, w * scale, h * scale);
            ctx.globalAlpha = 1;
            break;
            
          case 'zoomOut':
            if (prevFrame) {
              ctx.globalAlpha = 1 - progress;
              const s = 1 + progress * 0.5;
              const ox = (w - w * s) / 2;
              const oy = (h - h * s) / 2;
              ctx.drawImage(prevFrame, ox, oy, w * s, h * s);
            }
            ctx.globalAlpha = progress;
            ctx.drawImage(currentFrame, 0, 0, w, h);
            ctx.globalAlpha = 1;
            break;
            
          case 'wipeLeft':
            if (prevFrame) ctx.drawImage(prevFrame, 0, 0, w, h);
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, w * progress, h);
            ctx.clip();
            ctx.drawImage(currentFrame, 0, 0, w, h);
            ctx.restore();
            break;
            
          case 'wipeRight':
            if (prevFrame) ctx.drawImage(prevFrame, 0, 0, w, h);
            ctx.save();
            ctx.beginPath();
            ctx.rect(w * (1 - progress), 0, w * progress, h);
            ctx.clip();
            ctx.drawImage(currentFrame, 0, 0, w, h);
            ctx.restore();
            break;
            
          default:
            ctx.drawImage(currentFrame, 0, 0, w, h);
        }
      };

      // ==================== EXPORT ====================

      const exportVideo = async () => {
        const endTime = getRealEndTime();
        if (endTime <= 0) return;

        exportCancelRef.current = false;
        setIsExporting(true);
        setExportProgress(0);
        setShowExportModal(false);

        const quality = qualityPresets[exportQuality];
        const bitrate = quality.bitrate;

        try {
          setExportPhase('–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...');
          
          const canvas = document.createElement('canvas');
          canvas.width = projectSettings.width;
          canvas.height = projectSettings.height;
          const ctx = canvas.getContext('2d', { alpha: false });
          
          // –í—Ä–µ–º–µ–Ω–Ω—ã–π canvas –¥–ª—è –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –∫–∞–¥—Ä–∞ (–ø–µ—Ä–µ—Ö–æ–¥—ã)
          const prevCanvas = document.createElement('canvas');
          prevCanvas.width = projectSettings.width;
          prevCanvas.height = projectSettings.height;
          const prevCtx = prevCanvas.getContext('2d');

          const videoElements = {};
          for (const clip of clips) {
            if (clip.type === 'video') {
              const video = document.createElement('video');
              video.src = clip.src;
              video.muted = true;
              video.playsInline = true;
              video.preload = 'auto';
              await new Promise((resolve) => {
                video.oncanplaythrough = resolve;
                video.load();
              });
              videoElements[clip.id] = video;
            }
          }

          setExportPhase('–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∞—É–¥–∏–æ...');
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const masterGain = audioCtx.createGain();
          masterGain.connect(audioCtx.destination);
          const dest = audioCtx.createMediaStreamDestination();
          masterGain.connect(dest);

          const audioBuffers = {};
          for (const seg of [...voiceSegments, ...musicSegments]) {
            try {
              const response = await fetch(seg.src);
              const arrayBuffer = await response.arrayBuffer();
              audioBuffers[seg.id] = await audioCtx.decodeAudioData(arrayBuffer);
            } catch (e) {}
          }

          for (const clip of clips) {
            if (clip.type === 'video' && !clip.audioDetached) {
              try {
                const response = await fetch(clip.src);
                const arrayBuffer = await response.arrayBuffer();
                audioBuffers['video_' + clip.id] = await audioCtx.decodeAudioData(arrayBuffer);
              } catch (e) {}
            }
          }

          setExportPhase('–ó–∞–ø–∏—Å—å –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏...');

          const canvasStream = canvas.captureStream(30);
          dest.stream.getAudioTracks().forEach(track => canvasStream.addTrack(track));

          const chunks = [];
          const mediaRecorder = new MediaRecorder(canvasStream, {
            mimeType: 'video/webm;codecs=vp8,opus',
            videoBitsPerSecond: bitrate,
            audioBitsPerSecond: 128000
          });

          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) chunks.push(e.data);
          };

          const recordingComplete = new Promise((resolve) => {
            mediaRecorder.onstop = () => {
              const blob = new Blob(chunks, { type: 'video/webm' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'GlobalStudio_' + Date.now() + '.webm';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
              resolve();
            };
          });

          mediaRecorder.start(100);

          const audioSources = [];
          const startTime = audioCtx.currentTime + 0.1;

          for (const seg of [...voiceSegments, ...musicSegments]) {
            const buffer = audioBuffers[seg.id];
            if (!buffer) continue;
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = seg.volume;
            source.connect(gainNode);
            gainNode.connect(masterGain);
            source.start(startTime + seg.startTime, seg.trimStart, seg.trimEnd - seg.trimStart);
            audioSources.push(source);
          }

          for (const clip of clips) {
            if (clip.type === 'video' && !clip.audioDetached) {
              const buffer = audioBuffers['video_' + clip.id];
              if (!buffer) continue;
              const source = audioCtx.createBufferSource();
              source.buffer = buffer;
              const gainNode = audioCtx.createGain();
              gainNode.gain.value = clip.volume || 1;
              source.connect(gainNode);
              gainNode.connect(masterGain);
              source.start(startTime + clip.startTime, clip.trimStart, clip.trimEnd - clip.trimStart);
              audioSources.push(source);
            }
          }

          let exportStartTime = null;
          let lastClipId = null;
          let lastClipEndFrame = null;

          const renderFrame = (timestamp) => {
            if (exportCancelRef.current) {
              mediaRecorder.stop();
              audioSources.forEach(s => { try { s.stop(); } catch(e) {} });
              return;
            }

            if (!exportStartTime) exportStartTime = timestamp;
            const elapsed = (timestamp - exportStartTime) / 1000;

            if (elapsed >= endTime) {
              setTimeout(() => {
                mediaRecorder.stop();
                audioSources.forEach(s => { try { s.stop(); } catch(e) {} });
                audioCtx.close();
              }, 500);
              setExportPhase('–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...');
              return;
            }

            setExportProgress(Math.round((elapsed / endTime) * 100));
            setExportStatus(formatTime(elapsed) + ' / ' + formatTime(endTime));

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // –ù–∞—Ö–æ–¥–∏–º —Ç–µ–∫—É—â–∏–π –∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∫–ª–∏–ø –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–æ–≤
            let currentClip = null;
            let prevClip = null;
            
            for (let i = 0; i < clips.length; i++) {
              const clip = clips[i];
              const clipStart = clip.startTime;
              const clipEnd = clipStart + (clip.trimEnd - clip.trimStart);
              
              if (elapsed >= clipStart && elapsed < clipEnd) {
                currentClip = { ...clip, index: i };
                if (i > 0) prevClip = clips[i - 1];
                break;
              }
            }

            if (currentClip) {
              const localTime = currentClip.trimStart + (elapsed - currentClip.startTime);
              const transitionDur = currentClip.transitionDuration || 0.5;
              const inTransition = (elapsed - currentClip.startTime) < transitionDur && currentClip.transition !== 'none' && prevClip;

              // –†–∏—Å—É–µ–º –Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã–π canvas
              const drawClipToCanvas = (clip, targetCtx, time) => {
                if (clip.type === 'image') {
                  const img = videoCache.current[clip.id]?.element;
                  if (img && img.complete) {
                    const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                    const w = img.width * scale;
                    const h = img.height * scale;
                    targetCtx.drawImage(img, (canvas.width - w) / 2, (canvas.height - h) / 2, w, h);
                  }
                } else {
                  const video = videoElements[clip.id];
                  if (video && video.readyState >= 2) {
                    const scale = Math.min(canvas.width / video.videoWidth, canvas.height / video.videoHeight);
                    const w = video.videoWidth * scale;
                    const h = video.videoHeight * scale;
                    targetCtx.drawImage(video, (canvas.width - w) / 2, (canvas.height - h) / 2, w, h);
                  }
                }
              };

              if (inTransition && lastClipEndFrame) {
                // –ü–µ—Ä–µ—Ö–æ–¥
                const progress = (elapsed - currentClip.startTime) / transitionDur;
                
                // –í—Ä–µ–º–µ–Ω–Ω—ã–π canvas –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∫–∞–¥—Ä–∞
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.fillStyle = '#000000';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                drawClipToCanvas(currentClip, tempCtx, localTime);
                
                applyTransition(ctx, canvas, lastClipEndFrame, tempCanvas, progress, currentClip.transition);
              } else {
                drawClipToCanvas(currentClip, ctx, localTime);
              }

              // –ó–∞–ø—É—Å–∫–∞–µ–º –≤–∏–¥–µ–æ –µ—Å–ª–∏ –Ω–æ–≤—ã–π –∫–ª–∏–ø
              if (lastClipId !== currentClip.id) {
                const video = videoElements[currentClip.id];
                if (video) {
                  video.currentTime = localTime;
                  video.play().catch(() => {});
                }
                lastClipId = currentClip.id;
              }

              // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –∫–∞–¥—Ä –∫–ª–∏–ø–∞ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–æ–≤
              const clipEnd = currentClip.startTime + (currentClip.trimEnd - currentClip.trimStart);
              if (clipEnd - elapsed < 0.1) {
                prevCtx.drawImage(canvas, 0, 0);
                lastClipEndFrame = prevCanvas;
              }
            }

            // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç—ã —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π
            textOverlays.forEach(t => {
              if (elapsed >= t.startTime && elapsed < t.endTime) {
                const style = getTextStyleForExport(t, elapsed);
                ctx.save();
                ctx.globalAlpha = style.opacity;
                ctx.font = 'bold ' + t.fontSize + 'px Arial';
                ctx.fillStyle = t.color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.8)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.fillText(t.text, (t.x / 100) * canvas.width, (t.y / 100) * canvas.height);
                ctx.restore();
              }
            });

            requestAnimationFrame(renderFrame);
          };

          const getTextStyleForExport = (t, time) => {
            const elapsed = time - t.startTime;
            const remaining = t.endTime - time;
            const fadeTime = 0.5;
            let opacity = 1;
            if (t.animation === 'fadeIn' || t.animation === 'fadeInOut') {
              if (elapsed < fadeTime) opacity = elapsed / fadeTime;
            }
            if (t.animation === 'fadeOut' || t.animation === 'fadeInOut') {
              if (remaining < fadeTime) opacity = Math.min(opacity, remaining / fadeTime);
            }
            return { opacity: Math.max(0, Math.min(1, opacity)) };
          };

          await new Promise(r => setTimeout(r, 200));
          requestAnimationFrame(renderFrame);
          await recordingComplete;
          
          setIsExporting(false);
          setExportPhase('');
          setExportStatus('');

        } catch (error) {
          console.error('Export error:', error);
          setExportStatus('–û—à–∏–±–∫–∞: ' + error.message);
          setTimeout(() => setIsExporting(false), 3000);
        }
      };

      const cancelExport = () => {
        exportCancelRef.current = true;
        setExportStatus('–û—Ç–º–µ–Ω–∞...');
      };

      // ==================== RENDER ====================

      const renderSegment = (type, segment, color1, color2, icon) => {
        let segDuration, leftPercent, widthPercent;
        
        if (type === 'text') {
          segDuration = segment.endTime - segment.startTime;
          leftPercent = (segment.startTime / totalDuration) * 100;
          widthPercent = (segDuration / totalDuration) * 100;
        } else {
          segDuration = segment.trimEnd - segment.trimStart;
          leftPercent = (segment.startTime / totalDuration) * 100;
          widthPercent = (segDuration / totalDuration) * 100;
        }
        
        const isSelected = selectedItem?.type === type && selectedItem?.id === segment.id;
        
        return (
          <div
            key={segment.id}
            className={'timeline-segment ' + (isSelected ? 'selected' : '')}
            style={{
              left: leftPercent + '%',
              width: Math.max(widthPercent, 0.5) + '%',
              background: isSelected 
                ? 'linear-gradient(135deg, ' + color1 + ', ' + color2 + ')'
                : 'linear-gradient(135deg, ' + color2 + ', ' + color1 + '80)',
              minWidth: '30px'
            }}
            onMouseDown={(e) => handleDragStart(e, type, segment.id, 'move')}
            onTouchStart={(e) => handleDragStart(e, type, segment.id, 'move')}
            onClick={(e) => { e.stopPropagation(); setSelectedItem({ type, id: segment.id }); }}
          >
            <div className="resize-handle left" onMouseDown={(e) => handleDragStart(e, type, segment.id, 'resize-left')} onTouchStart={(e) => handleDragStart(e, type, segment.id, 'resize-left')} />
            <span style={{ marginLeft: '10px', pointerEvents: 'none' }}>{icon} {segment.name?.substring(0, 8) || segment.text?.substring(0, 8)}</span>
            <div className="resize-handle right" onMouseDown={(e) => handleDragStart(e, type, segment.id, 'resize-right')} onTouchStart={(e) => handleDragStart(e, type, segment.id, 'resize-right')} />
            
            {type === 'clip' && segment.transition !== 'none' && (
              <div className="transition-badge" onClick={(e) => { e.stopPropagation(); setShowTransitionModal(segment.id); }}>
                {TRANSITIONS[segment.transition]?.icon || '‚¨ú'}
              </div>
            )}
          </div>
        );
      };

      const selectedClip = selectedItem?.type === 'clip' ? clips.find(c => c.id === selectedItem.id) : null;
      const selectedVoice = selectedItem?.type === 'voice' ? voiceSegments.find(s => s.id === selectedItem.id) : null;
      const selectedMusic = selectedItem?.type === 'music' ? musicSegments.find(s => s.id === selectedItem.id) : null;
      const selectedText = selectedItem?.type === 'text' ? textOverlays.find(t => t.id === selectedItem.id) : null;

      return (
        <div style={{ height: '100vh', display: 'flex', flexDirection: 'column', background: 'linear-gradient(135deg, #0a0a0f, #1a1a2e)' }}>
          
          {voiceSegments.map(s => <audio key={s.id} ref={el => voiceRefs.current[s.id] = el} src={s.src} style={{ display: 'none' }} />)}
          {musicSegments.map(s => <audio key={s.id} ref={el => musicRefs.current[s.id] = el} src={s.src} style={{ display: 'none' }} />)}

          {/* Header */}
          <header style={{ background: 'linear-gradient(135deg, rgba(26,31,46,0.95), rgba(15,20,25,0.95))', padding: '10px 15px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderBottom: '1px solid var(--cg-border)', flexWrap: 'wrap', gap: '8px' }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
              <span style={{ fontSize: isMobile ? '16px' : '18px', fontWeight: 700, background: 'linear-gradient(135deg, #FFD700, #FFA500)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>üé¨ GlobalStudio</span>
              <span style={{ fontSize: '10px', padding: '3px 8px', background: 'rgba(255,215,0,0.2)', borderRadius: '4px', color: '#FFD700', fontWeight: 600 }}>v7.0</span>
              {/* Language switcher */}
              <div style={{ display: 'flex', gap: '2px', background: 'var(--cg-bg-lighter)', padding: '3px', borderRadius: '8px', border: '1px solid var(--cg-border)' }}>
                {['en', 'ru', 'uk'].map(l => (
                  <button key={l} onClick={() => setLang(l)} className={'lang-btn ' + (lang === l ? 'active' : '')}>{l.toUpperCase()}</button>
                ))}
              </div>
            </div>
            <div style={{ display: 'flex', gap: '8px', alignItems: 'center', flexWrap: 'wrap' }}>
              <button className="btn btn-secondary" onClick={() => setShowHelp(true)} title="–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è">‚ùì</button>
              <span className="desktop-only" style={{ fontSize: '12px', color: 'var(--cg-text-muted)', padding: '4px 10px', background: 'var(--cg-bg-lighter)', borderRadius: '6px' }}>üìê {projectSettings.width}√ó{projectSettings.height}</span>
              <button className="btn btn-success desktop-only" onClick={duplicateSelectedItem} disabled={!selectedItem} title="Ctrl+D">üìã {t.duplicate}</button>
              <button className="btn btn-danger desktop-only" onClick={splitAtPlayhead} disabled={!selectedItem || selectedItem.type === 'text'} title="S">‚úÇÔ∏è</button>
              <button className="btn btn-secondary" onClick={() => setShowTemplates(true)}>‚öôÔ∏è {isMobile ? '' : t.format}</button>
              <button className="btn btn-primary" onClick={() => setShowExportModal(true)} disabled={clips.length === 0}>üì§ {t.export}</button>
            </div>
          </header>

          {/* Main */}
          <div style={{ display: 'flex', flex: 1, overflow: 'hidden', flexDirection: isMobile ? 'column' : 'row' }}>
            
            {/* Left panel */}
            {!isMobile && <aside style={{ width: '220px', background: 'linear-gradient(180deg, var(--cg-bg-card), var(--cg-bg-dark))', borderRight: '1px solid var(--cg-border)', display: 'flex', flexDirection: 'column' }}>
              <div style={{ display: 'flex', borderBottom: '1px solid var(--cg-border)' }}>
                {['media', 'audio', 'text', 'banner'].map(tab => (
                  <button key={tab} onClick={() => setActiveTab(tab)} style={{
                    flex: 1, padding: '10px 8px', background: activeTab === tab ? 'rgba(255,215,0,0.15)' : 'transparent',
                    border: 'none', borderBottom: activeTab === tab ? '2px solid var(--cg-gold)' : '2px solid transparent',
                    color: activeTab === tab ? 'var(--cg-gold)' : 'var(--cg-text-muted)', cursor: 'pointer', fontSize: '11px', fontWeight: 500
                  }}>
                    {tab === 'media' ? 'üìÅ' : tab === 'audio' ? 'üéµ' : tab === 'text' ? '‚úèÔ∏è' : 'üè∑Ô∏è'} {t[tab]}
                  </button>
                ))}
              </div>

              <div style={{ flex: 1, overflow: 'auto', padding: '12px' }}>
                {activeTab === 'media' && (
                  <>
                    <button onClick={() => fileInputRef.current?.click()} className="btn btn-primary" style={{ width: '100%', padding: '12px', marginBottom: '12px' }}>üìé {t.addMedia}</button>
                    <input ref={fileInputRef} type="file" accept="video/*,image/*" multiple onChange={handleFileUpload} style={{ display: 'none' }} />
                    <div style={{ fontSize: '11px', color: 'var(--cg-text-muted)', marginBottom: '10px' }}>{clips.length} —Ñ–∞–π–ª–æ–≤ ‚Ä¢ {formatTime(realEndTime)}</div>
                    {clips.map((c, i) => (
                      <div key={c.id} onClick={() => setSelectedItem({ type: 'clip', id: c.id })} style={{
                        padding: '10px', marginBottom: '6px', borderRadius: '8px', cursor: 'pointer',
                        background: selectedItem?.id === c.id ? 'rgba(255,215,0,0.15)' : 'var(--cg-bg-lighter)',
                        border: selectedItem?.id === c.id ? '1px solid var(--cg-gold)' : '1px solid transparent'
                      }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                          <span style={{ fontSize: '10px', color: '#00d4ff' }}>{c.type === 'video' ? 'üé¨' : 'üñºÔ∏è'} {i + 1}</span>
                          <span style={{ fontSize: '9px', color: '#666' }}>{formatTime(c.trimEnd - c.trimStart)}</span>
                        </div>
                        <div style={{ fontSize: '9px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', marginTop: '2px' }}>{c.name}</div>
                        {c.transition !== 'none' && (
                          <div style={{ fontSize: '8px', color: '#ff9800', marginTop: '2px' }}>{TRANSITIONS[c.transition]} {t.trans[c.transition]}</div>
                        )}
                      </div>
                    ))}
                  </>
                )}
                
                {activeTab === 'audio' && (
                  <>
                    <div style={{ marginBottom: '16px' }}>
                      <div style={{ fontSize: '11px', color: '#00d4ff', marginBottom: '6px', fontWeight: 600 }}>üé§ {t.addVoice.split(' ')[1] || 'Voice'}</div>
                      <button onClick={() => voiceInputRef.current?.click()} className="btn btn-secondary" style={{ width: '100%', fontSize: '10px', marginBottom: '6px' }}>‚ûï {t.addVoice}</button>
                      <input ref={voiceInputRef} type="file" accept="audio/*" onChange={handleVoiceUpload} style={{ display: 'none' }} />
                      {voiceSegments.map(s => (
                        <div key={s.id} onClick={() => setSelectedItem({ type: 'voice', id: s.id })} style={{
                          padding: '6px', marginBottom: '4px', borderRadius: '4px', cursor: 'pointer',
                          background: selectedItem?.id === s.id ? 'rgba(0,212,255,0.2)' : 'rgba(0,212,255,0.1)'
                        }}>
                          <div style={{ fontSize: '9px' }}>üé§ {s.name?.substring(0, 15)}</div>
                        </div>
                      ))}
                    </div>
                    <div>
                      <div style={{ fontSize: '11px', color: '#bb86fc', marginBottom: '6px', fontWeight: 600 }}>üéµ –ú—É–∑—ã–∫–∞</div>
                      <button onClick={() => musicInputRef.current?.click()} className="btn btn-secondary" style={{ width: '100%', fontSize: '10px', marginBottom: '6px' }}>‚ûï –î–æ–±–∞–≤–∏—Ç—å</button>
                      <input ref={musicInputRef} type="file" accept="audio/*" onChange={handleMusicUpload} style={{ display: 'none' }} />
                      {musicSegments.map(s => (
                        <div key={s.id} onClick={() => setSelectedItem({ type: 'music', id: s.id })} style={{
                          padding: '6px', marginBottom: '4px', borderRadius: '4px', cursor: 'pointer',
                          background: selectedItem?.id === s.id ? 'rgba(187,134,252,0.3)' : 'rgba(187,134,252,0.1)'
                        }}>
                          <div style={{ fontSize: '9px' }}>üéµ {s.name?.substring(0, 15)}</div>
                        </div>
                      ))}
                    </div>
                  </>
                )}
                
                {activeTab === 'text' && (
                  <>
                    <button onClick={addTextOverlay} className="btn btn-primary" style={{ width: '100%', marginBottom: '8px' }}>‚ûï {t.addText}</button>
                    <p style={{ fontSize: '9px', color: '#666', marginBottom: '8px' }}>{t.position}: {formatTime(currentTime)}</p>
                    {textOverlays.map(txt => (
                      <div key={txt.id} onClick={() => setSelectedItem({ type: 'text', id: txt.id })} style={{
                        padding: '8px', marginBottom: '4px', borderRadius: '6px', cursor: 'pointer',
                        background: selectedItem?.id === txt.id ? 'rgba(255,200,0,0.2)' : 'rgba(255,255,255,0.05)',
                        border: selectedItem?.id === txt.id ? '1px solid #ffc800' : '1px solid transparent'
                      }}>
                        <div style={{ fontSize: '10px', fontWeight: 600 }}>‚úèÔ∏è {txt.text.substring(0, 15)}</div>
                        <div style={{ fontSize: '8px', color: '#888', marginTop: '2px' }}>{formatTime(txt.startTime)} - {formatTime(txt.endTime)}</div>
                      </div>
                    ))}
                  </>
                )}
                
                {activeTab === 'banner' && (
                  <BannerGenerator t={t} banners={banners} setBanners={setBanners} />
                )}
              </div>
            </aside>}

            {/* Preview */}
            <main style={{ flex: 1, display: 'flex', flexDirection: 'column', background: 'rgba(0,0,0,0.2)' }}>
              <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', padding: isMobile ? '8px' : '10px' }}>
                <div style={{
                  width: projectSettings.width > projectSettings.height ? (isMobile ? '100%' : '90%') : (isMobile ? '60%' : '45%'),
                  maxWidth: projectSettings.width > projectSettings.height ? '700px' : '350px',
                  aspectRatio: projectSettings.width + '/' + projectSettings.height,
                  background: '#000', borderRadius: '8px', position: 'relative', overflow: 'hidden',
                  boxShadow: '0 10px 40px rgba(0,0,0,0.5)'
                }}>
                  {!currentClipData ? (
                    <div style={{ height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#444', fontSize: '12px', textAlign: 'center', padding: '16px' }}>
                      {clips.length === 0 ? 'üé¨ ' + t.addMediaHint : '‚¨õ ' + t.emptySection}
                    </div>
                  ) : currentClipData.clip.type === 'video' ? (
                    <video ref={videoRef} style={{ width: '100%', height: '100%', objectFit: 'contain' }} muted={currentClipData.clip.audioDetached} playsInline />
                  ) : (
                    <img src={currentClipData.clip.src} style={{ width: '100%', height: '100%', objectFit: 'contain' }} alt="" />
                  )}
                  
                  {/* –¢–µ–∫—Å—Ç—ã —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π */}
                  {visibleTexts.map(txt => {
                    const style = getTextStyle(txt);
                    return (
                      <div key={txt.id} style={{ 
                        position: 'absolute', 
                        left: txt.x + '%', 
                        top: txt.y + '%', 
                        transform: 'translate(-50%,-50%)', 
                        color: txt.color, 
                        fontSize: (txt.fontSize * (isMobile ? 0.2 : 0.3)) + 'px', 
                        fontWeight: 'bold', 
                        textShadow: '2px 2px 4px #000', 
                        pointerEvents: 'none',
                        opacity: style.opacity,
                        transition: 'opacity 0.1s'
                      }}>{t.text}</div>
                    );
                  })}
                </div>
              </div>
              
              {/* Controls */}
              <div style={{ padding: '10px 16px', background: 'rgba(0,0,0,0.4)', display: 'flex', alignItems: 'center', gap: '10px' }}>
                <button onClick={togglePlay} className="btn btn-primary" style={{ width: '40px', height: '40px', borderRadius: '50%', padding: 0, fontSize: '16px' }}>{isPlaying ? '‚è∏' : '‚ñ∂Ô∏è'}</button>
                <span style={{ color: '#00d4ff', fontFamily: 'monospace', fontSize: '12px', minWidth: '60px' }}>{formatTimeMs(currentTime)}</span>
                <input type="range" min="0" max={totalDuration} step="0.1" value={currentTime} onChange={e => setCurrentTime(parseFloat(e.target.value))} style={{ flex: 1 }} />
                <span style={{ color: '#00ff00', fontFamily: 'monospace', fontSize: '12px' }}>üèÅ {formatTime(realEndTime)}</span>
              </div>
            </main>

            {/* Right panel - Properties */}
            {!isMobile && <aside style={{ width: '220px', background: 'rgba(0,0,0,0.3)', borderLeft: '1px solid rgba(255,255,255,0.1)', padding: '10px', overflow: 'auto' }}>
              <h3 style={{ fontSize: '11px', color: '#00d4ff', marginBottom: '10px', textTransform: 'uppercase' }}>{t.selectElement?.split(' ')[0] || 'Properties'}</h3>
              
              {selectedClip && (
                <>
                  <div style={{ fontSize: '11px', marginBottom: '10px', padding: '8px', background: 'rgba(0,212,255,0.1)', borderRadius: '6px' }}>
                    {selectedClip.type === 'video' ? 'üé¨' : 'üñºÔ∏è'} {selectedClip.name?.substring(0, 20)}
                  </div>
                  
                  {/* –ü–µ—Ä–µ—Ö–æ–¥ */}
                  <div style={{ marginBottom: '10px' }}>
                    <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>üéûÔ∏è {t.transition}</label>
                    <select value={selectedClip.transition} onChange={e => updateClip(selectedClip.id, { transition: e.target.value })} style={{ width: '100%' }}>
                      {Object.entries(TRANSITIONS).map(([key, icon]) => (
                        <option key={key} value={key}>{icon} {t.trans[key]}</option>
                      ))}
                    </select>
                  </div>
                  
                  {selectedClip.transition !== 'none' && (
                    <div style={{ marginBottom: '10px' }}>
                      <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>‚è±Ô∏è {t.transDur}: {selectedClip.transitionDuration}s</label>
                      <input type="range" min="0.2" max="2" step="0.1" value={selectedClip.transitionDuration} onChange={e => updateClip(selectedClip.id, { transitionDuration: parseFloat(e.target.value) })} />
                    </div>
                  )}
                  
                  {selectedClip.type === 'video' && !selectedClip.audioDetached && (
                    <div style={{ marginBottom: '10px' }}>
                      <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>üîä {t.volume}: {Math.round((selectedClip.volume || 1) * 100)}%</label>
                      <input type="range" min="0" max="1" step="0.05" value={selectedClip.volume || 1} onChange={e => updateClip(selectedClip.id, { volume: parseFloat(e.target.value) })} />
                    </div>
                  )}
                  
                  {/* –û—Ç—Å–æ–µ–¥–∏–Ω–∏—Ç—å –∞—É–¥–∏–æ */}
                  {selectedClip.type === 'video' && (
                    <button onClick={() => toggleAudioDetach(selectedClip.id)} className="btn btn-secondary" style={{ width: '100%', fontSize: '10px', marginBottom: '8px' }}>
                      {selectedClip.audioDetached ? 'üîä ' + (lang === 'ru' ? '–í–µ—Ä–Ω—É—Ç—å –∑–≤—É–∫' : lang === 'uk' ? '–ü–æ–≤–µ—Ä–Ω—É—Ç–∏ –∑–≤—É–∫' : 'Attach Audio') : 'üîá ' + (lang === 'ru' ? '–û—Ç—Å–æ–µ–¥–∏–Ω–∏—Ç—å' : lang === 'uk' ? '–í—ñ–¥–æ–∫—Ä–µ–º–∏—Ç–∏' : 'Detach Audio')}
                    </button>
                  )}
                  
                  <div style={{ marginBottom: '10px' }}>
                    <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>üìç {t.position}: {formatTime(selectedClip.startTime)}</label>
                    <input type="range" min="0" max={totalDuration} step="0.1" value={selectedClip.startTime} onChange={e => updateClip(selectedClip.id, { startTime: parseFloat(e.target.value) })} />
                  </div>
                  
                  <div style={{ display: 'flex', gap: '6px', marginBottom: '8px' }}>
                    <button onClick={duplicateSelectedItem} className="btn btn-success" style={{ flex: 1, fontSize: '9px' }}>üìã {t.duplicate}</button>
                    <button onClick={splitSelectedItem} className="btn btn-secondary" style={{ flex: 1, fontSize: '9px' }}>‚úÇÔ∏è</button>
                  </div>
                  
                  <button onClick={() => deleteClip(selectedClip.id)} className="btn btn-danger" style={{ width: '100%', fontSize: '10px' }}>üóëÔ∏è {t.delete}</button>
                </>
              )}
              
              {selectedText && (
                <>
                  <div style={{ fontSize: '11px', marginBottom: '10px', padding: '8px', background: 'rgba(255,200,0,0.1)', borderRadius: '6px' }}>
                    ‚úèÔ∏è {t.text}
                  </div>
                  
                  <div style={{ marginBottom: '10px' }}>
                    <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>{t.text}</label>
                    <input type="text" value={selectedText.text} onChange={e => updateText(selectedText.id, { text: e.target.value })}
                      style={{ width: '100%', padding: '6px', background: 'rgba(0,0,0,0.3)', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '4px', color: '#fff', fontSize: '11px' }} />
                  </div>
                  
                  <div style={{ marginBottom: '10px', display: 'flex', gap: '8px' }}>
                    <div style={{ flex: 1 }}>
                      <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>{t.color}</label>
                      <input type="color" value={selectedText.color} onChange={e => updateText(selectedText.id, { color: e.target.value })} style={{ width: '100%', height: '30px', border: 'none', borderRadius: '4px' }} />
                    </div>
                    <div style={{ flex: 1 }}>
                      <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>{t.size}</label>
                      <input type="number" value={selectedText.fontSize} min="12" max="200" onChange={e => updateText(selectedText.id, { fontSize: parseInt(e.target.value) || 24 })} className="input-small" style={{ width: '100%' }} />
                    </div>
                  </div>
                  
                  <div style={{ marginBottom: '10px', display: 'flex', gap: '8px' }}>
                    <div style={{ flex: 1 }}>
                      <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>X –ø–æ–∑–∏—Ü–∏—è %</label>
                      <input type="number" value={selectedText.x} min="0" max="100" onChange={e => updateText(selectedText.id, { x: parseInt(e.target.value) || 50 })} className="input-small" style={{ width: '100%' }} />
                    </div>
                    <div style={{ flex: 1 }}>
                      <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>Y –ø–æ–∑–∏—Ü–∏—è %</label>
                      <input type="number" value={selectedText.y} min="0" max="100" onChange={e => updateText(selectedText.id, { y: parseInt(e.target.value) || 50 })} className="input-small" style={{ width: '100%' }} />
                    </div>
                  </div>
                  
                  <div style={{ marginBottom: '10px' }}>
                    <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>üé¨ –ê–Ω–∏–º–∞—Ü–∏—è</label>
                    <select value={selectedText.animation} onChange={e => updateText(selectedText.id, { animation: e.target.value })} style={{ width: '100%' }}>
                      <option value="none">–ë–µ–∑ –∞–Ω–∏–º–∞—Ü–∏–∏</option>
                      <option value="fadeIn">–ü–ª–∞–≤–Ω–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ</option>
                      <option value="fadeOut">–ü–ª–∞–≤–Ω–æ–µ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ</option>
                      <option value="fadeInOut">–ü–æ—è–≤–ª–µ–Ω–∏–µ + –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ</option>
                    </select>
                  </div>
                  
                  <div style={{ marginBottom: '10px', display: 'flex', gap: '8px' }}>
                    <div style={{ flex: 1 }}>
                      <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>‚è±Ô∏è –ù–∞—á–∞–ª–æ</label>
                      <input type="number" value={selectedText.startTime.toFixed(1)} min="0" step="0.1" onChange={e => updateText(selectedText.id, { startTime: parseFloat(e.target.value) || 0 })} className="input-small" style={{ width: '100%' }} />
                    </div>
                    <div style={{ flex: 1 }}>
                      <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>‚è±Ô∏è –ö–æ–Ω–µ—Ü</label>
                      <input type="number" value={selectedText.endTime.toFixed(1)} min="0" step="0.1" onChange={e => updateText(selectedText.id, { endTime: parseFloat(e.target.value) || 5 })} className="input-small" style={{ width: '100%' }} />
                    </div>
                  </div>
                  
                  <button onClick={() => deleteText(selectedText.id)} className="btn btn-danger" style={{ width: '100%', fontSize: '10px' }}>üóëÔ∏è –£–¥–∞–ª–∏—Ç—å</button>
                </>
              )}
              
              {(selectedVoice || selectedMusic) && (
                <>
                  <div style={{ fontSize: '11px', marginBottom: '10px', padding: '8px', background: selectedVoice ? 'rgba(0,212,255,0.1)' : 'rgba(187,134,252,0.1)', borderRadius: '6px' }}>
                    {selectedVoice ? 'üé§' : 'üéµ'} {(selectedVoice || selectedMusic).name?.substring(0, 20)}
                  </div>
                  
                  <div style={{ marginBottom: '10px' }}>
                    <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>üìç –ü–æ–∑–∏—Ü–∏—è: {formatTime((selectedVoice || selectedMusic).startTime)}</label>
                    <input type="range" min="0" max={totalDuration} step="0.1" value={(selectedVoice || selectedMusic).startTime}
                      onChange={e => (selectedVoice ? updateVoice : updateMusic)((selectedVoice || selectedMusic).id, { startTime: parseFloat(e.target.value) })} />
                  </div>
                  
                  <div style={{ marginBottom: '10px' }}>
                    <label style={{ fontSize: '10px', color: '#888', display: 'block', marginBottom: '4px' }}>üîä –ì—Ä–æ–º–∫–æ—Å—Ç—å: {Math.round((selectedVoice || selectedMusic).volume * 100)}%</label>
                    <input type="range" min="0" max="1" step="0.05" value={(selectedVoice || selectedMusic).volume}
                      onChange={e => (selectedVoice ? updateVoice : updateMusic)((selectedVoice || selectedMusic).id, { volume: parseFloat(e.target.value) })} />
                  </div>
                  
                  <div style={{ display: 'flex', gap: '6px', marginBottom: '8px' }}>
                    <button onClick={duplicateSelectedItem} className="btn btn-success" style={{ flex: 1, fontSize: '9px' }}>üìã {t.duplicate}</button>
                    <button onClick={splitSelectedItem} className="btn btn-secondary" style={{ flex: 1, fontSize: '9px' }}>‚úÇÔ∏è</button>
                  </div>
                  
                  <button onClick={() => (selectedVoice ? deleteVoice : deleteMusic)((selectedVoice || selectedMusic).id)} className="btn btn-danger" style={{ width: '100%', fontSize: '10px' }}>üóëÔ∏è {t.delete}</button>
                </>
              )}
              
              {!selectedItem && (
                <div style={{ color: '#555', textAlign: 'center', padding: '20px', fontSize: '11px' }}>üëÜ {t.selectElement}</div>
              )}
            </aside>}
          </div>

          {/* Timeline */}
          <div ref={timelineRef} style={{ height: isMobile ? '140px' : '180px', background: 'rgba(0,0,0,0.5)', borderTop: '1px solid rgba(255,255,255,0.1)', padding: '8px' }}>
            <div style={{ height: '20px', marginLeft: isMobile ? '45px' : '60px', position: 'relative', marginBottom: '4px' }}>
              {Array.from({ length: Math.ceil(totalDuration / 5) + 1 }).map((_, i) => (
                <span key={i} style={{ position: 'absolute', left: ((i * 5 / totalDuration) * 100) + '%', fontSize: '9px', color: '#555', transform: 'translateX(-50%)' }}>{formatTime(i * 5)}</span>
              ))}
            </div>

            <div className="track-row">
              <div className="track-label" style={{ color: '#00d4ff' }}>üé¨</div>
              <div className="track-content">
                {clips.map(c => renderSegment('clip', c, '#00d4ff', c.type === 'video' ? '#1e3a5f' : '#5a3d1e', c.type === 'video' ? 'üé¨' : 'üñºÔ∏è'))}
                <div style={{ position: 'absolute', left: ((currentTime / totalDuration) * 100) + '%', top: '-5px', bottom: '-5px', width: '2px', background: '#ff0000', zIndex: 50, pointerEvents: 'none' }}>
                  <div style={{ position: 'absolute', top: '-8px', left: '-6px', width: '14px', height: '14px', background: '#ff0000', borderRadius: '50%' }} />
                </div>
              </div>
            </div>

            <div className="track-row">
              <div className="track-label" style={{ color: '#ffc800' }}>‚úèÔ∏è</div>
              <div className="track-content">
                {textOverlays.map(txt => renderSegment('text', txt, '#ffc800', '#5f4a00', '‚úèÔ∏è'))}
              </div>
            </div>

            <div className="track-row">
              <div className="track-label" style={{ color: '#00d4ff' }}>üé§</div>
              <div className="track-content">{voiceSegments.map(s => renderSegment('voice', s, '#00d4ff', '#005566', 'üé§'))}</div>
            </div>

            <div className="track-row">
              <div className="track-label" style={{ color: '#bb86fc' }}>üéµ</div>
              <div className="track-content">{musicSegments.map(s => renderSegment('music', s, '#bb86fc', '#3d1e5f', 'üéµ'))}</div>
            </div>
          </div>

          {/* Mobile bottom tabs */}
          {isMobile && (
            <div style={{ display: 'flex', background: 'rgba(0,0,0,0.8)', borderTop: '1px solid rgba(255,255,255,0.1)', paddingBottom: 'env(safe-area-inset-bottom)' }}>
              {['media', 'audio', 'text', 'banner'].map(tab => (
                <button key={tab} onClick={() => setActiveTab(tab)} style={{
                  flex: 1, padding: '12px 8px', background: activeTab === tab ? 'rgba(0,212,255,0.2)' : 'transparent',
                  border: 'none', borderTop: activeTab === tab ? '2px solid #00d4ff' : '2px solid transparent',
                  color: activeTab === tab ? '#00d4ff' : '#888', cursor: 'pointer', fontSize: '18px'
                }}>
                  {tab === 'media' ? 'üìÅ' : tab === 'audio' ? 'üéµ' : tab === 'text' ? '‚úèÔ∏è' : 'üè∑Ô∏è'}
                </button>
              ))}
            </div>
          )}

          {/* Mobile panel */}
          {isMobile && activeTab && (
            <div style={{ position: 'fixed', bottom: '60px', left: 0, right: 0, background: 'linear-gradient(135deg, #1a1a2e, #16213e)', borderTop: '1px solid rgba(255,255,255,0.1)', maxHeight: '40vh', overflow: 'auto', padding: '12px', paddingBottom: 'calc(12px + env(safe-area-inset-bottom))' }}>
              {activeTab === 'media' && (
                <button onClick={() => fileInputRef.current?.click()} className="btn btn-primary" style={{ width: '100%' }}>üìé {t.addMedia}</button>
              )}
              {activeTab === 'audio' && (
                <div style={{ display: 'flex', gap: '8px' }}>
                  <button onClick={() => voiceInputRef.current?.click()} className="btn btn-secondary" style={{ flex: 1 }}>üé§ {t.addVoice}</button>
                  <button onClick={() => musicInputRef.current?.click()} className="btn btn-secondary" style={{ flex: 1 }}>üéµ {t.addMusic}</button>
                </div>
              )}
              {activeTab === 'text' && (
                <button onClick={addTextOverlay} className="btn btn-primary" style={{ width: '100%' }}>‚úèÔ∏è {t.addText}</button>
              )}
              {activeTab === 'banner' && <BannerGenerator t={t} banners={banners} setBanners={setBanners} />}
            </div>
          )}

          {/* Modals */}
          {showExportModal && (
            <div className="modal-overlay" onClick={() => setShowExportModal(false)}>
              <div className="modal-content" onClick={e => e.stopPropagation()}>
                <h2 style={{ fontSize: '20px', color: 'var(--cg-gold)', marginBottom: '20px' }}>üì§ {t.export}</h2>
                <p style={{ fontSize: '12px', color: 'var(--cg-text-muted)', marginBottom: '16px' }}>{t.exportTime}: <span style={{ color: 'var(--cg-gold)' }}>{formatTime(realEndTime)}</span></p>
                <div style={{ marginBottom: '16px' }}>
                  {Object.entries(qualityPresets).map(([key, preset]) => (
                    <div key={key} onClick={() => setExportQuality(key)} style={{ padding: '14px', marginBottom: '8px', borderRadius: '10px', cursor: 'pointer', background: exportQuality === key ? 'rgba(255,215,0,0.15)' : 'var(--cg-bg-lighter)', border: exportQuality === key ? '2px solid var(--cg-gold)' : '2px solid transparent' }}>
                      <div style={{ fontWeight: 600, color: exportQuality === key ? 'var(--cg-gold)' : 'var(--cg-text)' }}>{t[preset.label] || preset.label}</div>
                      <div style={{ fontSize: '11px', color: 'var(--cg-text-muted)' }}>{preset.desc}</div>
                    </div>
                  ))}
                </div>
                <div style={{ display: 'flex', gap: '10px', justifyContent: 'flex-end' }}>
                  <button className="btn btn-secondary" onClick={() => setShowExportModal(false)}>{t.cancel}</button>
                  <button className="btn btn-primary" onClick={exportVideo}>üöÄ {t.start}</button>
                </div>
              </div>
            </div>
          )}

          {showTemplates && (
            <div className="modal-overlay" onClick={() => setShowTemplates(false)}>
              <div className="modal-content" onClick={e => e.stopPropagation()}>
                <h2 style={{ fontSize: '18px', color: 'var(--cg-gold)', marginBottom: '20px' }}>üìê {t.format}</h2>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '10px' }}>
                  {templates.map(tmpl => (
                    <button key={tmpl.id} onClick={() => { setProjectSettings(p => ({ ...p, width: tmpl.width, height: tmpl.height, format: tmpl.id })); setShowTemplates(false); }} style={{
                      padding: '16px', background: projectSettings.format === tmpl.id ? 'linear-gradient(135deg, var(--cg-gold), var(--cg-gold-dark))' : 'var(--cg-bg-lighter)',
                      border: projectSettings.format === tmpl.id ? '2px solid #fff' : '2px solid var(--cg-border)', borderRadius: '12px', color: projectSettings.format === tmpl.id ? '#000' : 'var(--cg-text)', cursor: 'pointer'
                    }}>
                      <div style={{ fontSize: '28px', marginBottom: '8px' }}>{tmpl.icon}</div>
                      <div style={{ fontSize: '13px', fontWeight: 600 }}>{t.fmt[tmpl.id] || tmpl.name}</div>
                      <div style={{ fontSize: '10px', color: projectSettings.format === tmpl.id ? 'rgba(0,0,0,0.6)' : 'var(--cg-text-muted)', marginTop: '4px' }}>{tmpl.width}√ó{tmpl.height}</div>
                    </button>
                  ))}
                </div>
              </div>
            </div>
          )}

          {isExporting && (
            <div className="modal-overlay">
              <div className="modal-content">
                <h2 style={{ fontSize: '18px', color: 'var(--cg-gold)', marginBottom: '8px' }}>üì§ {exportPhase}</h2>
                <p style={{ fontSize: '12px', color: 'var(--cg-text-muted)', marginBottom: '8px' }}>{exportStatus}</p>
                <div className="progress-bar"><div className="progress-fill" style={{ width: exportProgress + '%' }} /></div>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <span style={{ fontSize: '28px', color: 'var(--cg-gold)', fontWeight: 'bold' }}>{exportProgress}%</span>
                  <button className="btn btn-danger" onClick={cancelExport}>‚ùå –û—Ç–º–µ–Ω–∞</button>
                </div>
              </div>
            </div>
          )}

          {/* Help Modal */}
          {showHelp && (
            <div className="modal-overlay" onClick={() => setShowHelp(false)}>
              <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '700px', maxHeight: '85vh' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px' }}>
                  <h2 style={{ fontSize: '22px', color: 'var(--cg-gold)' }}>üìñ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è GlobalStudio v7.0</h2>
                  <button onClick={() => setShowHelp(false)} style={{ background: 'none', border: 'none', color: 'var(--cg-text-muted)', fontSize: '24px', cursor: 'pointer' }}>‚úï</button>
                </div>
                
                <div style={{ fontSize: '13px', lineHeight: '1.6', color: 'var(--cg-text)' }}>
                  
                  <h3 style={{ color: 'var(--cg-gold)', marginBottom: '10px', marginTop: '0' }}>üé¨ –û—Å–Ω–æ–≤—ã —Ä–∞–±–æ—Ç—ã</h3>
                  <p style={{ marginBottom: '15px', color: 'var(--cg-text-muted)' }}>
                    GlobalStudio ‚Äî –≤–∏–¥–µ–æ—Ä–µ–¥–∞–∫—Ç–æ—Ä –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ä–æ–ª–∏–∫–æ–≤ –∏–∑ –≤–∏–¥–µ–æ, —Ñ–æ—Ç–æ, –º—É–∑—ã–∫–∏ –∏ —Ç–µ–∫—Å—Ç–∞ –ø—Ä—è–º–æ –≤ –±—Ä–∞—É–∑–µ—Ä–µ.
                  </p>
                  
                  <h3 style={{ color: 'var(--cg-gold)', marginBottom: '10px' }}>üìÅ –í–∫–ª–∞–¥–∫–∞ "–ú–µ–¥–∏–∞"</h3>
                  <ul style={{ marginBottom: '15px', paddingLeft: '20px', color: 'var(--cg-text-muted)' }}>
                    <li>–ù–∞–∂–º–∏—Ç–µ <strong style={{ color: 'var(--cg-gold)' }}>üìé –î–æ–±–∞–≤–∏—Ç—å –≤–∏–¥–µ–æ/—Ñ–æ—Ç–æ</strong> –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤</li>
                    <li>–§–∞–π–ª—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –Ω–∞ —Ç–∞–π–º–ª–∞–π–Ω</li>
                    <li>–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –∫–ª–∏–ø –¥–ª—è –≤—ã–±–æ—Ä–∞ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è</li>
                    <li>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 5 —Å–µ–∫, –º–æ–∂–Ω–æ —Ä–∞—Å—Ç—è–Ω—É—Ç—å</li>
                  </ul>
                  
                  <h3 style={{ color: 'var(--cg-gold)', marginBottom: '10px' }}>üéµ –í–∫–ª–∞–¥–∫–∞ "–ó–≤—É–∫"</h3>
                  <ul style={{ marginBottom: '15px', paddingLeft: '20px', color: 'var(--cg-text-muted)' }}>
                    <li><strong>üé§ –ì–æ–ª–æ—Å</strong> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –æ–∑–≤—É—á–∫—É/–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π</li>
                    <li><strong>üéµ –ú—É–∑—ã–∫–∞</strong> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å —Ñ–æ–Ω–æ–≤—É—é –º—É–∑—ã–∫—É</li>
                    <li>–†–µ–≥—É–ª–∏—Ä—É–π—Ç–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å –¥–ª—è –∫–∞–∂–¥–æ–π –¥–æ—Ä–æ–∂–∫–∏</li>
                    <li>–ú–æ–∂–Ω–æ –æ—Ç–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫ —É –≤–∏–¥–µ–æ (–∫–Ω–æ–ø–∫–∞ üîä/üîá)</li>
                  </ul>
                  
                  <h3 style={{ color: 'var(--cg-gold)', marginBottom: '10px' }}>‚úèÔ∏è –í–∫–ª–∞–¥–∫–∞ "–¢–µ–∫—Å—Ç"</h3>
                  <ul style={{ marginBottom: '15px', paddingLeft: '20px', color: 'var(--cg-text-muted)' }}>
                    <li>–î–æ–±–∞–≤–ª—è–π—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –Ω–∞–¥–ø–∏—Å–∏ –ø–æ–≤–µ—Ä—Ö –≤–∏–¥–µ–æ</li>
                    <li>–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–æ–∑–∏—Ü–∏—é (X, Y –≤ %), —Ä–∞–∑–º–µ—Ä, —Ü–≤–µ—Ç</li>
                    <li>–£–∫–∞–∂–∏—Ç–µ –≤—Ä–µ–º—è –ø–æ—è–≤–ª–µ–Ω–∏—è –∏ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è</li>
                    <li>–í—ã–±–µ—Ä–∏—Ç–µ –∞–Ω–∏–º–∞—Ü–∏—é: –ø–ª–∞–≤–Ω–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ/–∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ</li>
                  </ul>
                  
                  <h3 style={{ color: 'var(--cg-gold)', marginBottom: '10px' }}>üè∑Ô∏è –í–∫–ª–∞–¥–∫–∞ "–ë–∞–Ω–Ω–µ—Ä"</h3>
                  <ul style={{ marginBottom: '15px', paddingLeft: '20px', color: 'var(--cg-text-muted)' }}>
                    <li>–°–æ–∑–¥–∞–≤–∞–π—Ç–µ HTML-–±–∞–Ω–Ω–µ—Ä—ã –¥–ª—è —Å–∞–π—Ç–æ–≤ –∏ –±–ª–æ–≥–æ–≤</li>
                    <li>–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç, –≤—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç–∞ —Ñ–æ–Ω–∞ –∏ —Ç–µ–∫—Å—Ç–∞</li>
                    <li>–î–æ–±–∞–≤—å—Ç–µ —ç—Ñ—Ñ–µ–∫—Ç—ã: –ø—É–ª—å—Å–∞—Ü–∏—è, –º–µ—Ä—Ü–∞–Ω–∏–µ, –≥—Ä–∞–¥–∏–µ–Ω—Ç</li>
                    <li>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –ª–æ–≥–æ—Ç–∏–ø –∏ —É–∫–∞–∂–∏—Ç–µ —Å—Å—ã–ª–∫—É</li>
                    <li>–ù–∞–∂–º–∏—Ç–µ <strong style={{ color: 'var(--cg-gold)' }}>üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å HTML</strong> ‚Äî –∫–æ–¥ –≥–æ—Ç–æ–≤ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏</li>
                    <li>–í—Å—Ç–∞–≤–ª—è–π—Ç–µ –≤ CardGift, –±–ª–æ–≥, email-—Ä–∞—Å—Å—ã–ª–∫–∏</li>
                  </ul>
                  
                  <h3 style={{ color: 'var(--cg-gold)', marginBottom: '10px' }}>üéöÔ∏è –¢–∞–π–º–ª–∞–π–Ω</h3>
                  <ul style={{ marginBottom: '15px', paddingLeft: '20px', color: 'var(--cg-text-muted)' }}>
                    <li><strong>–ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ</strong> ‚Äî –¥–≤–∏–≥–∞–π—Ç–µ –∫–ª–∏–ø—ã –ø–æ –≤—Ä–µ–º–µ–Ω–∏</li>
                    <li><strong>–ö—Ä–∞—è –∫–ª–∏–ø–∞</strong> ‚Äî —Ç—è–Ω–∏—Ç–µ –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ –Ω–∞—á–∞–ª–∞/–∫–æ–Ω—Ü–∞</li>
                    <li><strong>‚ûï/‚ûñ –ú–∞—Å—à—Ç–∞–±</strong> ‚Äî –ø—Ä–∏–±–ª–∏–∂–∞–π—Ç–µ –¥–ª—è —Ç–æ—á–Ω–æ–π —Ä–∞–±–æ—Ç—ã</li>
                    <li><strong>–í–≤–æ–¥ –≤—Ä–µ–º–µ–Ω–∏</strong> ‚Äî –≤–≤–µ–¥–∏—Ç–µ "1:30" –∏ Enter –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞</li>
                    <li><strong>‚úÇÔ∏è –†–∞–∑—Ä–µ–∑–∞—Ç—å</strong> ‚Äî –¥–µ–ª–∏—Ç –∫–ª–∏–ø –Ω–∞ 2 —á–∞—Å—Ç–∏ –≤ –ø–æ–∑–∏—Ü–∏–∏ –ø–æ–ª–∑—É–Ω–∫–∞</li>
                    <li><strong>–ö–ª–∏–∫ –ø–æ –ª–∏–Ω–µ–π–∫–µ</strong> ‚Äî –ø–µ—Ä–µ—Ö–æ–¥ –∫ –Ω—É–∂–Ω–æ–º—É –≤—Ä–µ–º–µ–Ω–∏</li>
                  </ul>
                  
                  <h3 style={{ color: 'var(--cg-gold)', marginBottom: '10px' }}>üé≠ –ü–µ—Ä–µ—Ö–æ–¥—ã –º–µ–∂–¥—É –∫–ª–∏–ø–∞–º–∏</h3>
                  <ul style={{ marginBottom: '15px', paddingLeft: '20px', color: 'var(--cg-text-muted)' }}>
                    <li>–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∏–ø ‚Üí –≤ –ø–∞–Ω–µ–ª–∏ —Å–ø—Ä–∞–≤–∞ –Ω–∞–π–¥–∏—Ç–µ "–ü–µ—Ä–µ—Ö–æ–¥"</li>
                    <li>–î–æ—Å—Ç—É–ø–Ω–æ: –ø–ª–∞–≤–Ω–æ–µ, —Å–ª–∞–π–¥, —É–≤–µ–ª–∏—á–µ–Ω–∏–µ, —à—Ç–æ—Ä–∫–∞</li>
                    <li>–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–µ—Ä–µ—Ö–æ–¥–∞ (0.1 - 2 —Å–µ–∫)</li>
                  </ul>
                  
                  <h3 style={{ color: 'var(--cg-gold)', marginBottom: '10px' }}>‚å®Ô∏è –ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏</h3>
                  <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '8px', marginBottom: '15px' }}>
                    <div style={{ background: 'var(--cg-bg-lighter)', padding: '8px', borderRadius: '6px' }}><kbd style={{ background: 'var(--cg-bg-dark)', padding: '2px 6px', borderRadius: '4px', color: 'var(--cg-gold)' }}>Space</kbd> –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ</div>
                    <div style={{ background: 'var(--cg-bg-lighter)', padding: '8px', borderRadius: '6px' }}><kbd style={{ background: 'var(--cg-bg-dark)', padding: '2px 6px', borderRadius: '4px', color: 'var(--cg-gold)' }}>S</kbd> –†–∞–∑—Ä–µ–∑–∞—Ç—å</div>
                    <div style={{ background: 'var(--cg-bg-lighter)', padding: '8px', borderRadius: '6px' }}><kbd style={{ background: 'var(--cg-bg-dark)', padding: '2px 6px', borderRadius: '4px', color: 'var(--cg-gold)' }}>Del</kbd> –£–¥–∞–ª–∏—Ç—å</div>
                    <div style={{ background: 'var(--cg-bg-lighter)', padding: '8px', borderRadius: '6px' }}><kbd style={{ background: 'var(--cg-bg-dark)', padding: '2px 6px', borderRadius: '4px', color: 'var(--cg-gold)' }}>Ctrl+D</kbd> –î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å</div>
                    <div style={{ background: 'var(--cg-bg-lighter)', padding: '8px', borderRadius: '6px' }}><kbd style={{ background: 'var(--cg-bg-dark)', padding: '2px 6px', borderRadius: '4px', color: 'var(--cg-gold)' }}>+/-</kbd> –ú–∞—Å—à—Ç–∞–±</div>
                    <div style={{ background: 'var(--cg-bg-lighter)', padding: '8px', borderRadius: '6px' }}><kbd style={{ background: 'var(--cg-bg-dark)', padding: '2px 6px', borderRadius: '4px', color: 'var(--cg-gold)' }}>‚Üê/‚Üí</kbd> ¬±1 —Å–µ–∫</div>
                    <div style={{ background: 'var(--cg-bg-lighter)', padding: '8px', borderRadius: '6px' }}><kbd style={{ background: 'var(--cg-bg-dark)', padding: '2px 6px', borderRadius: '4px', color: 'var(--cg-gold)' }}>Home</kbd> –í –Ω–∞—á–∞–ª–æ</div>
                    <div style={{ background: 'var(--cg-bg-lighter)', padding: '8px', borderRadius: '6px' }}><kbd style={{ background: 'var(--cg-bg-dark)', padding: '2px 6px', borderRadius: '4px', color: 'var(--cg-gold)' }}>End</kbd> –í –∫–æ–Ω–µ—Ü</div>
                  </div>
                  
                  <h3 style={{ color: 'var(--cg-gold)', marginBottom: '10px' }}>üì§ –≠–∫—Å–ø–æ—Ä—Ç –≤–∏–¥–µ–æ</h3>
                  <ul style={{ marginBottom: '15px', paddingLeft: '20px', color: 'var(--cg-text-muted)' }}>
                    <li>–ù–∞–∂–º–∏—Ç–µ <strong style={{ color: 'var(--cg-gold)' }}>üì§ –≠–∫—Å–ø–æ—Ä—Ç</strong> –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É</li>
                    <li>–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—á–µ—Å—Ç–≤–æ: –°—Ä–µ–¥–Ω–µ–µ (5Mbps), –í—ã—Å–æ–∫–æ–µ (10Mbps), –£–ª—å—Ç—Ä–∞ (20Mbps)</li>
                    <li>–ó–∞–ø–∏—Å—å –∏–¥—ë—Ç –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏ ‚Äî –¥–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è</li>
                    <li>–§–∞–π–ª —Å–∫–∞—á–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ .webm</li>
                  </ul>
                  
                  <h3 style={{ color: 'var(--cg-gold)', marginBottom: '10px' }}>‚öôÔ∏è –§–æ—Ä–º–∞—Ç—ã –ø—Ä–æ–µ–∫—Ç–∞</h3>
                  <ul style={{ marginBottom: '10px', paddingLeft: '20px', color: 'var(--cg-text-muted)' }}>
                    <li><strong>YouTube HD</strong> ‚Äî 1920√ó1080 (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –≤–∏–¥–µ–æ)</li>
                    <li><strong>YouTube 4K</strong> ‚Äî 3840√ó2160</li>
                    <li><strong>TikTok/Reels</strong> ‚Äî 1080√ó1920 (–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –≤–∏–¥–µ–æ)</li>
                    <li><strong>–ö–≤–∞–¥—Ä–∞—Ç</strong> ‚Äî 1080√ó1080 (Instagram –ø–æ—Å—Ç—ã)</li>
                    <li><strong>–ö–∏–Ω–æ 21:9</strong> ‚Äî 2560√ó1080 (—à–∏—Ä–æ–∫–∏–π —ç–∫—Ä–∞–Ω)</li>
                  </ul>
                  
                </div>
                
                <button className="btn btn-primary" onClick={() => setShowHelp(false)} style={{ width: '100%', marginTop: '15px', padding: '12px' }}>‚úì –ü–æ–Ω—è—Ç–Ω–æ!</button>
              </div>
            </div>
          )}
        </div>
      );
    };

    // ==================== BANNER GENERATOR ====================
    const BannerGenerator = ({ t, banners, setBanners }) => {
      const [bannerText, setBannerText] = useState(t.yourText);
      const [bgColor, setBgColor] = useState('#1a1f2e');
      const [textColor, setTextColor] = useState('#FFD700');
      const [effect, setEffect] = useState('none');
      const [logo, setLogo] = useState(null);
      const [link, setLink] = useState('');
      const logoInputRef = useRef(null);
      
      const handleLogoUpload = (e) => {
        const file = e.target.files[0];
        if (file) setLogo(URL.createObjectURL(file));
      };
      
      const generateHTML = () => {
        let effectStyle = '';
        if (effect === 'pulse') effectStyle = 'animation:pulse 2s infinite;';
        else if (effect === 'shimmer') effectStyle = 'background:linear-gradient(90deg,transparent,rgba(255,255,255,0.3),transparent);background-size:200% 100%;animation:shimmer 2s infinite;';
        else if (effect === 'gradient') effectStyle = `background:linear-gradient(135deg,${bgColor},${textColor}40);`;
        
        return `<div style="display:flex;align-items:center;gap:10px;padding:12px 16px;background:${effect !== 'gradient' ? bgColor : ''};border-radius:8px;cursor:pointer;${effectStyle}" onclick="window.open('${link}','_blank')">
${logo ? `<img src="${logo}" style="height:32px" alt=""/>` : ''}
<span style="color:${textColor};font-weight:600;font-size:14px">${bannerText}</span>
</div>
<style>@keyframes pulse{0%,100%{opacity:1}50%{opacity:.6}}@keyframes shimmer{0%{background-position:-200% 0}100%{background-position:200% 0}}</style>`;
      };
      
      const saveBanner = () => {
        setBanners(prev => [...prev, { id: Date.now(), text: bannerText, bgColor, textColor, effect, logo, link, html: generateHTML() }]);
      };
      
      const copyHTML = () => navigator.clipboard.writeText(generateHTML());
      
      return (
        <div>
          <h4 style={{ fontSize: '12px', color: '#ffc800', marginBottom: '10px' }}>üè∑Ô∏è {t.bannerTitle}</h4>
          
          {/* Preview */}
          <div style={{ marginBottom: '10px', padding: '10px', background: 'rgba(0,0,0,0.3)', borderRadius: '6px' }}>
            <div style={{ fontSize: '9px', color: '#666', marginBottom: '4px' }}>{t.preview}:</div>
            <div style={{ 
              display: 'flex', alignItems: 'center', gap: '10px', padding: '12px 16px', 
              background: effect === 'gradient' ? `linear-gradient(135deg, ${bgColor}, ${textColor}40)` : bgColor, 
              borderRadius: '8px'
            }} className={effect === 'shimmer' ? 'shimmer' : ''} style2={effect === 'pulse' ? {animation: 'pulse 2s infinite'} : {}}>
              {logo && <img src={logo} style={{ height: '28px' }} alt="" />}
              <span style={{ color: textColor, fontWeight: 600, fontSize: '13px' }}>{bannerText}</span>
            </div>
          </div>
          
          {/* Text */}
          <div style={{ marginBottom: '8px' }}>
            <label style={{ fontSize: '9px', color: '#888', display: 'block', marginBottom: '3px' }}>{t.text || 'Text'}</label>
            <input type="text" value={bannerText} onChange={e => setBannerText(e.target.value)} className="input-field" style={{ fontSize: '11px', padding: '6px 8px' }} />
          </div>
          
          {/* Colors */}
          <div style={{ marginBottom: '8px', display: 'flex', gap: '6px' }}>
            <div style={{ flex: 1 }}>
              <label style={{ fontSize: '9px', color: '#888', display: 'block', marginBottom: '3px' }}>{t.background}</label>
              <input type="color" value={bgColor} onChange={e => setBgColor(e.target.value)} style={{ width: '100%', height: '28px', border: 'none', borderRadius: '4px', cursor: 'pointer' }} />
            </div>
            <div style={{ flex: 1 }}>
              <label style={{ fontSize: '9px', color: '#888', display: 'block', marginBottom: '3px' }}>{t.color}</label>
              <input type="color" value={textColor} onChange={e => setTextColor(e.target.value)} style={{ width: '100%', height: '28px', border: 'none', borderRadius: '4px', cursor: 'pointer' }} />
            </div>
          </div>
          
          {/* Effect */}
          <div style={{ marginBottom: '8px' }}>
            <label style={{ fontSize: '9px', color: '#888', display: 'block', marginBottom: '3px' }}>{t.effect}</label>
            <select value={effect} onChange={e => setEffect(e.target.value)} style={{ width: '100%' }}>
              <option value="none">{t.noEffect}</option>
              <option value="pulse">{t.pulse}</option>
              <option value="shimmer">{t.shimmer}</option>
              <option value="gradient">{t.gradient}</option>
            </select>
          </div>
          
          {/* Logo */}
          <div style={{ marginBottom: '8px' }}>
            <input ref={logoInputRef} type="file" accept="image/*" onChange={handleLogoUpload} style={{ display: 'none' }} />
            <button onClick={() => logoInputRef.current?.click()} className="btn btn-secondary" style={{ width: '100%', fontSize: '10px' }}>
              üñºÔ∏è {t.uploadLogo}
            </button>
          </div>
          
          {/* Link */}
          <div style={{ marginBottom: '10px' }}>
            <label style={{ fontSize: '9px', color: '#888', display: 'block', marginBottom: '3px' }}>{t.link}</label>
            <input type="url" value={link} onChange={e => setLink(e.target.value)} placeholder="https://" className="input-field" style={{ fontSize: '11px', padding: '6px 8px' }} />
          </div>
          
          {/* Buttons */}
          <div style={{ display: 'flex', gap: '6px' }}>
            <button onClick={saveBanner} className="btn btn-success" style={{ flex: 1, fontSize: '10px' }}>üíæ {t.save}</button>
            <button onClick={copyHTML} className="btn btn-primary" style={{ flex: 1, fontSize: '10px' }}>üìã {t.copyHtml}</button>
          </div>
          
          {/* Saved */}
          {banners.length > 0 && (
            <div style={{ marginTop: '12px' }}>
              <div style={{ fontSize: '9px', color: '#888', marginBottom: '6px' }}>{t.savedBanners}:</div>
              {banners.map(b => (
                <div key={b.id} style={{ padding: '6px', marginBottom: '4px', background: 'rgba(255,255,255,0.05)', borderRadius: '4px', fontSize: '9px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <span>{b.text.substring(0, 18)}</span>
                  <button onClick={() => navigator.clipboard.writeText(b.html)} className="btn btn-secondary" style={{ padding: '3px 6px', fontSize: '8px' }}>üìã</button>
                </div>
              ))}
            </div>
          )}
        </div>
      );
    };

    ReactDOM.render(<GlobalStudio />, document.getElementById('root'));
  </script>
</body>
</html>
